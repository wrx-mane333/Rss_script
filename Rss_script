local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local ReachDistance = 1
local IsReachEnabled = false
local IsVisualizerEnabled = false
local HitboxSize = Vector3.new(10, 10, 10)
local ReachConnection = nil
local Ball = nil
local RSSHitbox = nil
getgenv().InfiniteStaminaEnabled = false

local function CreateHitbox()
    if RSSHitbox then RSSHitbox:Destroy() end
    RSSHitbox = Instance.new("Folder")
    RSSHitbox.Name = "RSSHitbox"
    RSSHitbox.Parent = Workspace

    -- Outer ring (subtle)
    local outer = Instance.new("BoxHandleAdornment")
    outer.Name = "Outer"
    outer.AlwaysOnTop = false
    outer.ZIndex = 1
    outer.Color3 = Color3.fromRGB(0, 150, 255)
    outer.Transparency = 1
    outer.Size = HitboxSize * 1.15
    outer.Adornee = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    outer.Parent = RSSHitbox

    -- Inner core (more visible)
    local core = Instance.new("BoxHandleAdornment")
    core.Name = "Core"
    core.AlwaysOnTop = true
    core.ZIndex = 2
    core.Color3 = Color3.fromRGB(0, 255, 100)
    core.Transparency = 1
    core.Size = HitboxSize
    core.Adornee = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    core.Parent = RSSHitbox

    -- Pulse helper to animate when visible
    local pulse = Instance.new("BoolValue")
    pulse.Name = "Pulse"
    pulse.Value = false
    pulse.Parent = RSSHitbox
end

local function UpdateHitbox()
    if not RSSHitbox or not RSSHitbox.Parent then return end

    local outer = RSSHitbox:FindFirstChild("Outer")
    local core = RSSHitbox:FindFirstChild("Core")

    if outer then
        outer.Size = HitboxSize * 1.15
        outer.Adornee = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    end

    if core then
        core.Size = HitboxSize
        core.Adornee = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    end

    local shouldShow = IsReachEnabled and IsVisualizerEnabled
    if outer then outer.Transparency = shouldShow and 0.85 or 1 end
    if core then core.Transparency = shouldShow and 0.55 or 1 end
end

local function GetRoot() 
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end

local function FindBall()
    -- Robust ball finder: checks common names and models, returns a BasePart representing the ball
    local function firstPartFromModel(m)
        if not m then return nil end
        if m:IsA("BasePart") then return m end
        if m.PrimaryPart and m.PrimaryPart:IsA("BasePart") then return m.PrimaryPart end
        for _, c in ipairs(m:GetDescendants()) do
            if c:IsA("BasePart") then return c end
        end
        return nil
    end

    local names = {"ball", "Ball", "PSoccerBall", "TPS", "SoccerBall"}
    for _, name in ipairs(names) do
        local found = Workspace:FindFirstChild(name, true)
        if found then
            local part = firstPartFromModel(found)
            if part then return part end
        end
    end

    -- fallback: search for a floating spherical part with expected size
    for _, part in ipairs(Workspace:GetDescendants()) do
        if part:IsA("BasePart") and (part.Shape == Enum.PartType.Ball or (part.Mesh and string.find(string.lower(part.Name), "ball") )) then
            return part
        end
    end

    return nil
end

local function ReachLoop()
    local root = GetRoot()
    if not root or not RSSHitbox then return end
    local outer = RSSHitbox:FindFirstChild("Outer")
    local core = RSSHitbox:FindFirstChild("Core")
    if outer then outer.Adornee = root end
    if core then core.Adornee = root end

    local ball = FindBall()
    if not ball or not ball.Position then return end

    local effectiveReach = math.max(HitboxSize.X, HitboxSize.Y, HitboxSize.Z) * 0.6

    if (ball.Position - root.Position).Magnitude <= effectiveReach then
        -- only touch a few key parts to reduce anti-cheat noise
        local partsToTouch = {}
        local char = LocalPlayer.Character
        if char then
            for _, name in ipairs({"LeftHand","RightHand","LeftFoot","RightFoot","HumanoidRootPart","LowerTorso"}) do
                local p = char:FindFirstChild(name)
                if p and p:IsA("BasePart") then table.insert(partsToTouch, p) end
            end
            if #partsToTouch == 0 then
                for _, p in ipairs(char:GetChildren()) do if p:IsA("BasePart") then table.insert(partsToTouch, p) end end
            end
        end

        for _, part in ipairs(partsToTouch) do
            pcall(function()
                firetouchinterest(part, ball, 0)
                task.wait(0.012)
                firetouchinterest(part, ball, 1)
            end)
        end
    end
end

local function EnableReach()
    if ReachConnection then return end
    IsReachEnabled = true
    UpdateHitbox()
    ReachConnection = RunService.Heartbeat:Connect(ReachLoop)
end

local function DisableReach()
    if ReachConnection then 
        ReachConnection:Disconnect() 
        ReachConnection = nil 
    end
    IsReachEnabled = false
    UpdateHitbox()
end

local speeds = nil
local defaultWalk = 16

local function SetupStamina()
    pcall(function()
        local gui = LocalPlayer:WaitForChild("PlayerGui", 10)
        local stamina = gui:WaitForChild("Stamina", 10)
        local frame = stamina:WaitForChild("Frame", 5)
        speeds = frame:WaitForChild("Speeds", 5)
        defaultWalk = speeds.Walk.Value

        if InfiniteStaminaEnabled and speeds then
            speeds.Walk.Value = speeds.Run.Value
        end
    end)
end

SetupStamina()
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    SetupStamina()
end)

-- Safe helpers for mobile dive buttons and firing them
function safeFindDiveButtons()
    local ok, gui = pcall(function()
        return LocalPlayer:FindFirstChild("PlayerGui")
    end)
    if not ok or not gui then return nil end

    local candidates = {
        {"MobileCTRL","TouchControlFrame","JumpButton"},
        {"MobileControls","TouchFrame","JumpBtn"},
        {"MobileCTRL","TouchControlFrame","DPad"},
    }

    for _, path in ipairs(candidates) do
        local node = gui
        for _, name in ipairs(path) do
            node = node and node:FindFirstChild(name)
            if not node then break end
        end
        if node then
            local left = node:FindFirstChild("LeftDive") or node:FindFirstChild("Left")
            local right = node:FindFirstChild("RightDive") or node:FindFirstChild("Right")
            if left and right then
                return left, right
            end
        end
    end

    return nil
end

function tryClick(btn)
    if not btn then return end
    pcall(function()
        if getconnections then
            local ok, conns = pcall(getconnections, btn.MouseButton1Click)
            if ok and type(conns) == 'table' and #conns > 0 and type(conns[1].Fire) == 'function' then
                conns[1]:Fire()
                return
            end
        end

        if btn.MouseButton1Click and type(btn.MouseButton1Click.Fire) == 'function' then
            btn.MouseButton1Click:Fire()
        end
    end)
end

local function safeLoadWindUI()
    local ok, lib = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"))()
    end)

    if ok and type(lib) == "table" then
        return lib
    end

    -- Minimal stub to avoid runtime errors when WindUI fails to load
    return setmetatable({}, {
        __index = function()
            return function() end
        end
    })
end

local WindUI = safeLoadWindUI()

local Window = WindUI:CreateWindow({
    Title = "RSS - VETA",
    Icon = "rbxassetid://106211849494703",
    Author = "Made By VETA",
    Folder = "RSSVETA",
})

local MainTab = Window:Tab({
    Title = "GK & Player Reach",
    Icon = "target",
})

local MainSection = MainTab:Section({
    Title = "Both Reach (Pretty Bad At GK)"
})

MainSection:Toggle({
    Title = "Enable Reach",
    Default = false,
    Callback = function(v)
        if v then
            EnableReach()
        else
            DisableReach()
        end
    end
})

MainSection:Toggle({
    Title = "Show Hitbox",
    Default = false,
    Callback = function(v)
        IsVisualizerEnabled = v
        UpdateHitbox()
    end
})

MainSection:Toggle({
    Title = "Performance Optimizer",
    Desc = "Disable particle effects / lights and pause predictor to reduce client lag",
    Default = false,
    Callback = function(v)
        ApplyOptimizations(v)
    end,
})

MainTab:Space()

local SizeSection = MainTab:Section({
    Title = "Hitbox Size (X/Y/Z)"
})

SizeSection:Slider({
    Title = "Size X",
    Step = 1,
    Value = {
        Min = 1,
        Max = 50,
        Default = 10,
    },
    Callback = function(v)
        HitboxSize = Vector3.new(v, HitboxSize.Y, HitboxSize.Z)
        UpdateHitbox()
    end
})

SizeSection:Slider({
    Title = "Size Y",
    Step = 1,
    Value = {
        Min = 1,
        Max = 50,
        Default = 10,
    },
    Callback = function(v)
        HitboxSize = Vector3.new(HitboxSize.X, v, HitboxSize.Z)
        UpdateHitbox()
    end
})

SizeSection:Slider({
    Title = "Size Z",
    Step = 1,
    Value = {
        Min = 1,
        Max = 50,
        Default = 10,
    },
    Callback = function(v)
        HitboxSize = Vector3.new(HitboxSize.X, HitboxSize.Y, v)
        UpdateHitbox()
    end
})

local GkTab = Window:Tab({
    Title = "GK Features",
    Icon = "rbxassetid://10734950020"
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local function isInFansTeam()
    return LocalPlayer.Team and LocalPlayer.Team.Name == "Fans"
end

local AutoPickSection = GkTab:Section({
    Title = "Auto Pick GK"
})

AutoPickSection:Dropdown({
    Title = "Choose Team",
    Desc = "USE THIS WHEN NO GK IN TEAM",
    Values = {"Home GK", "Away GK"},
    Value = nil,
    Multi = false,
    AllowNone = true,
    Callback = function(option)
        if not option or option == "" then
            return
        end
        
        if not isInFansTeam() then
            WindUI:Notify({
                Title = "Error",
                Icon = "ban",
                Content = "You must be in Fans/No Team to use this feature!",
                Duration = 5,
            })
            return
        end
        
        if option == "Home GK" then
            local args = {
                BrickColor.new(23),
                "Goalie"
            }
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(unpack(args))
        elseif option == "Away GK" then
            local args = {
                BrickColor.new(141),
                "Goalie"
            }
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(unpack(args))
        end
    end
})

local DiveSection = GkTab:Section({
        Title = "Auto Dive"
    })

local DiveToggle = DiveSection:Toggle({
    Title = "Auto Dive [BETA|MIGHT BUG]",
    Desc = "USE THIS WHEN BEING GK",
    Default = false,
    Callback = function(enabled)
        local RunService = game:GetService("RunService")

        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

        -- cleanup existing connection
        if getgenv().AutoDiveConnection then
            pcall(function() getgenv().AutoDiveConnection:Disconnect() end)
            getgenv().AutoDiveConnection = nil
        end

        if not enabled then return end

        local DIVE_DISTANCE = 10.5
        local DIVE_COOLDOWN = 0.65
        local SMART_DIVE = true

        local lastDiveTime = 0

        local function safeFindDiveButtons()
            local ok, gui = pcall(function()
                return LocalPlayer:WaitForChild("PlayerGui", 5)
            end)
            if not ok or not gui then return nil end

            local candidates = {
                {"MobileCTRL","TouchControlFrame","JumpButton"},
                {"MobileControls","TouchFrame","JumpBtn"},
                {"MobileCTRL","TouchControlFrame","DPad"},
            }

            for _, path in ipairs(candidates) do
                local node = gui
                for _, name in ipairs(path) do
                    node = node:FindFirstChild(name)
                    if not node then break end
                end
                if node then
                    local left = node:FindFirstChild("LeftDive") or node:FindFirstChild("Left")
                    local right = node:FindFirstChild("RightDive") or node:FindFirstChild("Right")
                    if left and right then
                        return left, right
                    end
                end
            end

            return nil
        end

        local function tryClick(btn)
            if not btn then return end
            pcall(function()
                local conns = (getconnections and pcall(getconnections, btn.MouseButton1Click) and getconnections(btn.MouseButton1Click)) or nil
                if type(conns) == "table" and #conns > 0 and type(conns[1].Fire) == 'function' then
                    conns[1]:Fire()
                    return
                end

                if btn.MouseButton1Click and type(btn.MouseButton1Click.Fire) == 'function' then
                    btn.MouseButton1Click:Fire()
                end
            end)
        end

        local leftBtn, rightBtn = safeFindDiveButtons()

        local function autoDive(ballPosition)
            local now = tick()
            if now - lastDiveTime < DIVE_COOLDOWN then return end

            if SMART_DIVE and HumanoidRootPart and ballPosition then
                local localPos = HumanoidRootPart.CFrame:PointToObjectSpace(ballPosition)
                if localPos.X < 0 then
                    tryClick(leftBtn)
                else
                    tryClick(rightBtn)
                end
            else
                tryClick(leftBtn)
            end

            lastDiveTime = now
        end

        getgenv().AutoDiveConnection = RunService.Heartbeat:Connect(function()
            local ball = workspace:FindFirstChild("ball") or workspace:FindFirstChild("PSoccerBall")
            if not ball then return end
            local bp = ball.Position or (ball:IsA("Model") and ball:FindFirstChildWhichIsA("BasePart") and ball:FindFirstChildWhichIsA("BasePart").Position)
            if not bp then return end

            local distance = (HumanoidRootPart.Position - bp).Magnitude
            if distance <= DIVE_DISTANCE then
                autoDive(bp)
            end
        end)
    end
})

local StaminaTab = Window:Tab({
    Title = "Infinite Stamina",
    Icon = "zap",
})

local StaminaSection = StaminaTab:Section({
    Title = "Infinite Stamina"
})

StaminaSection:Toggle({
    Title = "Enable Infinite Stamina",
    Default = false,
    Callback = function(v)
        getgenv().InfiniteStaminaEnabled = v
        if speeds then
            speeds.Walk.Value = v and speeds.Run.Value or defaultWalk
        end
    end
})

local PredictTab = Window:Tab({
    Title = "Ball Predictor",
    Icon = "circle",
})

local PredictSection = PredictTab:Section({
    Title = "Ball Predictor"
})

local predictionConnection = nil
local curveFolder = nil

PredictSection:Toggle({
    Title = "Enable Ball Predictor",
    Default = false,
    Callback = function(Value)
        if Value then
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local Workspace = game:GetService("Workspace")

            local config = {
                gravity = 196.2,
                bounceDamping = 0.68,
                groundHeight = 0,
                minBounceVelocity = 8,
                airResistance = 0.99,
                frictionCoefficient = 0.85,
                spinDecay = 0.95,
                magnusCoefficient = 0.00015,
                terminalVelocity = 200,
                rollingResistance = 0.92,
                
                segmentCount = 25,
                segmentSize = Vector3.new(0.3, 0.3, 2),
                segmentTransparency = 0.2,
                maxPredictionTime = 10,
                minVelocityThreshold = 3,
                simulationTimestep = 0.033,
                maxSimulationPoints = 80,
                updateRate = 3,
                
                colorCurve = Color3.fromRGB(0, 255, 0),
                colorLanding = Color3.fromRGB(0, 255, 0),
            }

            local vector3Zero = Vector3.zero
            local vector3Up = Vector3.new(0, 1, 0)
            local gravityVector = Vector3.new(0, -config.gravity, 0)

            local cachedBall = nil
            local lastBallCheck = 0
            local ballCheckInterval = 1

            local function getBall()
                local now = tick()
                if cachedBall and cachedBall.Parent and now - lastBallCheck < ballCheckInterval then
                    return cachedBall
                end
                
                lastBallCheck = now
                cachedBall = Workspace:FindFirstChild("TPS", true) 
                    or Workspace:FindFirstChild("PSoccerBall", true)
                    or Workspace:FindFirstChild("ball", true)
                
                return cachedBall
            end

            curveFolder = Instance.new("Folder")
            curveFolder.Name = "BallPredictionCurve"
            curveFolder.Parent = workspace

            local segments = table.create(config.segmentCount)
            for i = 1, config.segmentCount do
                local segment = Instance.new("Part")
                segment.Name = "Segment_" .. i
                segment.Anchored = true
                segment.CanCollide = false
                segment.CastShadow = false
                segment.Material = Enum.Material.Neon
                segment.Transparency = config.segmentTransparency
                segment.Size = config.segmentSize
                segment.Color = config.colorCurve
                segment.Parent = curveFolder
                segments[i] = segment
            end

            local landingMarker = Instance.new("Part")
            landingMarker.Name = "LandingMarker"
            landingMarker.Anchored = true
            landingMarker.CanCollide = false
            landingMarker.CastShadow = false
            landingMarker.Material = Enum.Material.Neon
            landingMarker.Color = config.colorLanding
            landingMarker.Transparency = 0.4
            landingMarker.Size = Vector3.new(4, 0.2, 4)
            landingMarker.Shape = Enum.PartType.Cylinder
            landingMarker.Parent = curveFolder

            local landingRing = Instance.new("Part")
            landingRing.Name = "LandingRing"
            landingRing.Anchored = true
            landingRing.CanCollide = false
            landingRing.CastShadow = false
            landingRing.Material = Enum.Material.Neon
            landingRing.Color = config.colorLanding
            landingRing.Transparency = 0.6
            landingRing.Size = Vector3.new(6, 0.1, 6)
            landingRing.Shape = Enum.PartType.Cylinder
            landingRing.Parent = curveFolder

            local function simulateTrajectory(startPos, startVel)
                local points = table.create(config.maxSimulationPoints)
                local dt = config.simulationTimestep
                local maxTime = config.maxPredictionTime
                local gravityDt = gravityVector * dt
                local airResistance = config.airResistance ^ dt
                
                local pos = startPos
                local vel = startVel
                local time = 0
                local bounceCount = 0
                local pointCount = 0
                
                while time < maxTime and bounceCount < 8 and pointCount < config.maxSimulationPoints do
                    time = time + dt
                    pointCount = pointCount + 1
                    
                    vel = (vel + gravityDt) * airResistance
                    
                    if vel.Y < -config.terminalVelocity then
                        vel = Vector3.new(vel.X, -config.terminalVelocity, vel.Z)
                    end
                    
                    pos = pos + vel * dt
                    
                    points[pointCount] = {pos, vel, vel.Magnitude}
                    
                    if pos.Y <= config.groundHeight and vel.Y < 0 then
                        pos = Vector3.new(pos.X, config.groundHeight, pos.Z)
                        
                        local bounceVelY = -vel.Y * config.bounceDamping
                        vel = Vector3.new(
                            vel.X * config.frictionCoefficient,
                            bounceVelY,
                            vel.Z * config.frictionCoefficient
                        )
                        
                        bounceCount = bounceCount + 1
                        
                        if vel.Magnitude < config.minBounceVelocity then
                            points[pointCount] = {pos, vector3Zero, 0}
                            break
                        end
                    end
                    
                    if pos.Y < -500 or vel.Magnitude < 0.3 then
                        break
                    end
                end
                
                return points, pointCount
            end

            local function findFirstLanding(points, count)
                for i = 2, count do
                    local curr = points[i]
                    local prev = points[i-1]
                    local currPos, currVel = curr[1], curr[2]
                    local prevPos, prevVel = prev[1], prev[2]
                    
                    if currPos.Y <= config.groundHeight + 0.5 and 
                       prevPos.Y > config.groundHeight + 0.5 and
                       currVel.Y < 0 then
                        
                        local t = (config.groundHeight - prevPos.Y) / (currPos.Y - prevPos.Y)
                        t = math.clamp(t, 0, 1)
                        
                        return prevPos:Lerp(currPos, t), prevVel:Lerp(currVel, t)
                    end
                end
                return nil, nil
            end

            local frameCounter = 0
            local lastTrajectoryPoints = nil
            local lastPointCount = 0
            local lastLandingPos = nil
            local lastLandingVel = nil

            predictionConnection = RunService.Heartbeat:Connect(function()
                frameCounter = frameCounter + 1
                
                if frameCounter % config.updateRate ~= 0 then
                    return
                end
                
                local ball = getBall()
                if not ball then
                    for i = 1, config.segmentCount do
                        segments[i].Transparency = 1
                    end
                    landingMarker.Transparency = 1
                    landingRing.Transparency = 1
                    return
                end
                
                local velocity = ball.AssemblyLinearVelocity
                local speed = velocity.Magnitude
                
                if speed < config.minVelocityThreshold then
                    for i = 1, config.segmentCount do
                        segments[i].Transparency = 1
                    end
                    landingMarker.Transparency = 1
                    landingRing.Transparency = 1
                    return
                end
                
                local trajectoryPoints, pointCount = simulateTrajectory(ball.Position, velocity)
                lastTrajectoryPoints = trajectoryPoints
                lastPointCount = pointCount
                
                if pointCount > 1 then
                    local segmentStep = (pointCount - 1) / (config.segmentCount - 1)
                    
                    for i = 1, config.segmentCount do
                        local pointIndex = math.floor((i - 1) * segmentStep) + 1
                        local nextIndex = math.min(pointIndex + 1, pointCount)
                        
                        if pointIndex <= pointCount and nextIndex <= pointCount then
                            local current = trajectoryPoints[pointIndex]
                            local next = trajectoryPoints[nextIndex]
                            local currentPos, nextPos = current[1], next[1]
                            
                            local midpoint = (currentPos + nextPos) * 0.5
                            local distance = (nextPos - currentPos).Magnitude
                            
                            if distance > 0.01 then
                                local direction = (nextPos - currentPos) / distance
                                
                                segments[i].Size = Vector3.new(0.3, 0.3, distance)
                                segments[i].CFrame = CFrame.lookAt(midpoint, midpoint + direction)
                                segments[i].Transparency = config.segmentTransparency
                            else
                                segments[i].Transparency = 1
                            end
                        else
                            segments[i].Transparency = 1
                        end
                    end
                else
                    for i = 1, config.segmentCount do
                        segments[i].Transparency = 1
                    end
                end
                
                local landingPos, landingVel = findFirstLanding(trajectoryPoints, pointCount)
                lastLandingPos = landingPos
                lastLandingVel = landingVel
                
                if landingPos then
                    local markerPos = landingPos + Vector3.new(0, 0.1, 0)
                    landingMarker.CFrame = CFrame.new(markerPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                    landingMarker.Transparency = 0.4
                    
                    local ringPos = landingPos + Vector3.new(0, 0.05, 0)
                    landingRing.CFrame = CFrame.new(ringPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                    landingRing.Transparency = 0.6
                    
                    local pulse = math.sin(tick() * 5) * 0.5 + 0.5
                    local scale = 6 + pulse
                    landingRing.Size = Vector3.new(scale, 0.1, scale)
                else
                    landingMarker.Transparency = 1
                    landingRing.Transparency = 1
                end
            end)
        else
            if predictionConnection then
                predictionConnection:Disconnect()
                predictionConnection = nil
            end
            
            if curveFolder then
                curveFolder:Destroy()
                curveFolder = nil
            end
        end
    end
})
CreateHitbox()
UpdateHitbox()

-- Performance optimization: disable client-side heavy effects and optionally pause predictor/visuals
local OptimizationsApplied = false
local savedStates = {}
local wasPredictorEnabled = false

local function disableEffects()
    savedStates = {particles = {}, trails = {}, beams = {}, lights = {}}
    for _, obj in ipairs(Workspace:GetDescendants()) do
        pcall(function()
            if obj:IsA("ParticleEmitter") then
                savedStates.particles[obj] = obj.Enabled
                obj.Enabled = false
            elseif obj:IsA("Trail") then
                savedStates.trails[obj] = obj.Enabled
                obj.Enabled = false
            elseif obj:IsA("Beam") then
                savedStates.beams[obj] = obj.Enabled
                obj.Enabled = false
            elseif obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") then
                savedStates.lights[obj] = obj.Enabled
                obj.Enabled = false
            end
        end)
    end

    -- attempt to reduce Lighting costs
    pcall(function()
        local Lighting = game:GetService("Lighting")
        savedStates.lighting = {GlobalShadows = Lighting.GlobalShadows, Brightness = Lighting.Brightness}
        Lighting.GlobalShadows = false
        Lighting.Brightness = math.max(0.5, Lighting.Brightness * 0.5)
    end)
end

local function restoreEffects()
    for obj, state in pairs(savedStates.particles or {}) do pcall(function() obj.Enabled = state end) end
    for obj, state in pairs(savedStates.trails or {}) do pcall(function() obj.Enabled = state end) end
    for obj, state in pairs(savedStates.beams or {}) do pcall(function() obj.Enabled = state end) end
    for obj, state in pairs(savedStates.lights or {}) do pcall(function() obj.Enabled = state end) end
    if savedStates.lighting then
        pcall(function()
            local Lighting = game:GetService("Lighting")
            Lighting.GlobalShadows = savedStates.lighting.GlobalShadows
            Lighting.Brightness = savedStates.lighting.Brightness
        end)
    end
    savedStates = {}
end

local function ApplyOptimizations(enable)
    if enable and not OptimizationsApplied then
        -- pause predictor if running
        if predictionConnection then
            wasPredictorEnabled = true
            pcall(function() predictionConnection:Disconnect() end)
            predictionConnection = nil
        else
            wasPredictorEnabled = false
        end

        disableEffects()
        -- hide heavy visuals
        IsVisualizerEnabled = false
        UpdateHitbox()
        OptimizationsApplied = true
        WindUI:Notify({Title = "Optimizer", Content = "Optimizations applied", Icon = "zap"})
    elseif not enable and OptimizationsApplied then
        restoreEffects()
        if wasPredictorEnabled then
            -- user can re-enable predictor via UI toggle; we avoid auto-starting to be safe
            WindUI:Notify({Title = "Optimizer", Content = "Predictor was running before; re-enable it from UI if needed", Icon = "info"})
        end
        OptimizationsApplied = false
        WindUI:Notify({Title = "Optimizer", Content = "Optimizations removed", Icon = "check"})
    end
end

local PlayerTab = Window:Tab({
    Title = "Player",
    Icon = "user",
})

local PlayerSection = PlayerTab:Section({
    Title = "Soon."
})

local Dialog = Window:Dialog({
    Icon = "bird",
    Title = "Hey!",
    Content = "Report To Our Discord If You Found Bugs/Glitches",
    Buttons = {
        {
            Title = "Continue",
            Callback = function()
                -- safe noop: CreateMainUI may not be defined in some environments
                if type(CreateMainUI) == "function" then
                    pcall(CreateMainUI)
                end
            end
        }
    }
})

-- Ensure CreateMainUI exists (some dialogs call it)
function CreateMainUI()
    -- intentionally minimal: if the real WindUI window init is elsewhere, this won't interfere
    pcall(function()
        WindUI:Notify({
            Title = "UI",
            Icon = "check",
            Content = "Main UI initialized",
            Duration = 2,
        })
    end)
end

WindUI:Notify({
    Title = "RSS Loaded",
    Icon = "check",
    Content = "Go Fuck RSS"
})

local AdvancedGKSection = GkTab:Section({
    Title = "Auto GK V2 (Predictive)"
})

AdvancedGKSection:Toggle({
    Title = "Enable Auto GK V2",
    Desc = "Predicts and dives towards ball landing",
    Default = false,
    Callback = function(enabled)
        local RunService = game:GetService("RunService")

        if getgenv().AutoGKV2Connection then
            pcall(function() getgenv().AutoGKV2Connection:Disconnect() end)
            getgenv().AutoGKV2Connection = nil
        end

        if not enabled then return end

        local DIVE_COOLDOWN = 0.8
        local MAX_LOOKAHEAD = 2.2
        local STEP = 0.05
        local lastDive = 0
        local leftBtn, rightBtn = nil, nil

        -- reuse button finder from Auto Dive if available
        local function findButtonsLocal()
            if type(safeFindDiveButtons) == 'function' then
                return safeFindDiveButtons()
            end
            return nil
        end

        leftBtn, rightBtn = findButtonsLocal()

        local function tryClickLocal(b)
            if type(tryClick) == 'function' then
                return tryClick(b)
            end
            pcall(function() if b and b.MouseButton1Click then b.MouseButton1Click:Fire() end end)
        end

        local function predictLanding(pos, vel)
            local g = Vector3.new(0, -196.2, 0)
            local p = pos
            local v = vel
            for t = 0, MAX_LOOKAHEAD, STEP do
                local dt = STEP
                v = v + g * dt
                p = p + v * dt
                if p.Y <= 3 then -- near ground
                    return p
                end
            end
            return nil
        end

        getgenv().AutoGKV2Connection = RunService.Heartbeat:Connect(function()
            local ball = workspace:FindFirstChild("ball") or workspace:FindFirstChild("PSoccerBall")
            if not ball then return end
            local bp = ball.Position
            local bv = ball.AssemblyLinearVelocity or Vector3.new()
            if not bp then return end

            local landing = predictLanding(bp, bv)
            if not landing then return end

            local char = LocalPlayer.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            if not root then return end

            local dist = (root.Position - landing).Magnitude
            if dist > 18 then return end -- only dive if landing fairly close

            local now = tick()
            if now - lastDive < DIVE_COOLDOWN then return end

            local localPos = root.CFrame:PointToObjectSpace(landing)
            if localPos.X < 0 then
                tryClickLocal(leftBtn)
            else
                tryClickLocal(rightBtn)
            end

            lastDive = now
        end)
    end
})
