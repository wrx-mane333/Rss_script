---@diagnostic disable: undefined-global, undefined-field, deprecated
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local ReachDistance = 1
local IsReachEnabled = false
local IsVisualizerEnabled = false
local HitboxSize = Vector3.new(10, 10, 10)
local ReachConnection = nil
local Ball = nil
local RSSHitbox = nil
getgenv().InfiniteStaminaEnabled = false

-- Optimization: Cached objects
local _CachedBall = nil
local _CachedGoalBounds = nil
local _LastBallSearch = 0
local PlayerGameMode = "7v7" -- режим по умолчанию: 7v7 или 4v4

local function CreateHitbox()
    if RSSHitbox then RSSHitbox:Destroy() end
    RSSHitbox = Instance.new("Folder")
    RSSHitbox.Name = "RSSHitbox"
    RSSHitbox.Parent = Workspace

    -- Outer ring (subtle)
    local outer = Instance.new("BoxHandleAdornment")
    outer.Name = "Outer"
    outer.AlwaysOnTop = false
    outer.ZIndex = 1
    outer.Color3 = Color3.fromRGB(0, 150, 255)
    outer.Transparency = 1
    outer.Size = HitboxSize * 1.15
    outer.Adornee = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    outer.Parent = RSSHitbox

    -- Inner core (more visible)
    local core = Instance.new("BoxHandleAdornment")
    core.Name = "Core"
    core.AlwaysOnTop = true
    core.ZIndex = 2
    core.Color3 = Color3.fromRGB(0, 255, 100)
    core.Transparency = 1
    core.Size = HitboxSize
    core.Adornee = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    core.Parent = RSSHitbox

    -- Pulse helper to animate when visible
    local pulse = Instance.new("BoolValue")
    pulse.Name = "Pulse"
    pulse.Value = false
    pulse.Parent = RSSHitbox
end

local function UpdateHitbox()
    if not RSSHitbox or not RSSHitbox.Parent then return end

    local outer = RSSHitbox:FindFirstChild("Outer")
    local core = RSSHitbox:FindFirstChild("Core")

    if outer then
        outer.Size = HitboxSize * 1.15
        outer.Adornee = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    end

    if core then
        core.Size = HitboxSize
        core.Adornee = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    end

    local shouldShow = IsReachEnabled and IsVisualizerEnabled
    if outer then outer.Transparency = shouldShow and 0.5 or 1 end
    if core then core.Transparency = shouldShow and 0.3 or 1 end
end

local function GetRoot() 
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end

local function FindBall()
    local now = tick()
    if _CachedBall and _CachedBall.Parent and now - _LastBallSearch < 0.5 then
        return _CachedBall
    end
    _LastBallSearch = now

    -- Robust ball finder: checks common names and models
    local function firstPartFromModel(m)
        if not m then return nil end
        if m:IsA("BasePart") then return m end
        if m.PrimaryPart and m.PrimaryPart:IsA("BasePart") then return m.PrimaryPart end
        -- Search children instead of descendants for speed
        for _, c in ipairs(m:GetChildren()) do
            if c:IsA("BasePart") then return c end
        end
        return nil
    end

    local names = {"ball", "Ball", "PSoccerBall", "TPS", "SoccerBall", "Football", "Ball1"}
    for _, name in ipairs(names) do
        -- Search in Workspace children first (faster than recursive)
        local found = Workspace:FindFirstChild(name)
        if found then
            local part = firstPartFromModel(found)
            if part then 
                _CachedBall = part
                return part 
            end
        end
    end

    -- If not found, do a more expensive search but rarely
    if now - _LastBallSearch > 2 then
        for _, name in ipairs(names) do
            local found = Workspace:FindFirstChild(name, true)
            if found then
                local part = firstPartFromModel(found)
                if part then 
                    _CachedBall = part
                    return part 
                end
            end
        end
    end

    return nil
end

-- Returns active ball part, position and velocity (if available)
local function GetBallData()
    local b = FindBall()
    if not b then return nil end
    local pos = nil
    local vel = Vector3.new()
    pcall(function()
        pos = b.Position
        vel = b.AssemblyLinearVelocity or b.Velocity or Vector3.new()
    end)
    return b, pos, vel
end

-- Find goal-related parts and compute an axis-aligned bounding box covering them
local function findGoalBounds()
    if _CachedGoalBounds then return _CachedGoalBounds end

    local candidates = {}
    -- Optimization: Search likely folders first
    local folders = {Workspace:FindFirstChild("Map"), Workspace:FindFirstChild("Goals")}
    
    for _, parent in ipairs(folders) do
        if parent then
            for _, obj in ipairs(parent:GetDescendants()) do
                if obj:IsA("BasePart") then
                    local lname = string.lower(obj.Name)
                    if string.find(lname, "goal") or string.find(lname, "net") or string.find(lname, "post") or string.find(lname, "goalzone") then
                        table.insert(candidates, obj)
                    end
                end
            end
        end
    end

    -- Fallback: Search Workspace children (not descendants) if nothing found yet
    if #candidates == 0 then
        for _, obj in ipairs(Workspace:GetChildren()) do
             if obj:IsA("Model") or obj:IsA("Folder") then
                -- Check name of model/folder
                local lname = string.lower(obj.Name)
                 if string.find(lname, "goal") or string.find(lname, "net") then
                    for _, child in ipairs(obj:GetDescendants()) do
                        if child:IsA("BasePart") then table.insert(candidates, child) end
                    end
                 end
             elseif obj:IsA("BasePart") then
                local lname = string.lower(obj.Name)
                if string.find(lname, "goal") or string.find(lname, "net") or string.find(lname, "post") or string.find(lname, "goalzone") then
                    table.insert(candidates, obj)
                end
             end
        end
    end

    if #candidates == 0 then return nil end

    local minV = Vector3.new(1e9,1e9,1e9)
    local maxV = Vector3.new(-1e9,-1e9,-1e9)
    for _, p in ipairs(candidates) do
        local size = p.Size * 0.5
        local cpos = p.Position
        local a = cpos - size
        local b = cpos + size
        minV = Vector3.new(math.min(minV.X, a.X), math.min(minV.Y, a.Y), math.min(minV.Z, a.Z))
        maxV = Vector3.new(math.max(maxV.X, b.X), math.max(maxV.Y, b.Y), math.max(maxV.Z, b.Z))
    end
    _CachedGoalBounds = {min = minV, max = maxV}
    return _CachedGoalBounds
end

local function isPointInBounds(pt, bounds)
    if not pt or not bounds then return false end
    return pt.X >= bounds.min.X and pt.X <= bounds.max.X and pt.Y >= bounds.min.Y and pt.Y <= bounds.max.Y and pt.Z >= bounds.min.Z and pt.Z <= bounds.max.Z
end

-- Simulate short trajectory to check whether ball will enter goal bounds within lookahead seconds
local function isBallHeadingToGoal(ballPart, velocity, lookahead)
    if not ballPart or not velocity then return false, nil end
    lookahead = lookahead or 2
    local bounds = findGoalBounds()
    if not bounds then return false, nil end

    local g = Vector3.new(0, -196.2, 0)
    local pos = ballPart.Position
    local vel = velocity
    local dt = 0.05
    local time = 0
    while time < lookahead do
        vel = vel + g * dt
        pos = pos + vel * dt
        time = time + dt
        if isPointInBounds(pos, bounds) then
            return true, pos
        end
        if pos.Y < -200 then break end
    end
    return false, nil
end

local function ReachLoop()
    local root = GetRoot()
    if not root or not RSSHitbox then return end
    local outer = RSSHitbox:FindFirstChild("Outer")
    local core = RSSHitbox:FindFirstChild("Core")
    if outer then outer.Adornee = root end
    if core then core.Adornee = root end

    local ball = FindBall()
    if not ball or not ball.Position then return end

    local effectiveReach = math.max(HitboxSize.X, HitboxSize.Y, HitboxSize.Z) * 0.6
    local dist = (ball.Position - root.Position).Magnitude

    if dist <= effectiveReach then
        -- Optimization: cache char and parts
        local char = LocalPlayer.Character
        if not char then return end

        -- Only trigger touch if close enough to minimize firetouchinterest calls
        local partsToTouch = {"LeftHand","RightHand","LeftFoot","RightFoot","HumanoidRootPart"}
        for _, name in ipairs(partsToTouch) do
            local p = char:FindFirstChild(name)
            if p and p:IsA("BasePart") then
                pcall(function()
                    firetouchinterest(p, ball, 0)
                    firetouchinterest(p, ball, 1)
                end)
            end
        end
    end
end

local function EnableReach()
    if ReachConnection then return end
    IsReachEnabled = true
    UpdateHitbox()
    ReachConnection = RunService.Heartbeat:Connect(ReachLoop)
end

local function DisableReach()
    if ReachConnection then 
        ReachConnection:Disconnect() 
        ReachConnection = nil 
    end
    IsReachEnabled = false
    UpdateHitbox()
end

local speeds = nil
local defaultWalk = 16

local function SetupStamina()
    pcall(function()
        local gui = LocalPlayer:WaitForChild("PlayerGui", 10)
        local stamina = gui:WaitForChild("Stamina", 10)
        local frame = stamina:WaitForChild("Frame", 5)
        speeds = frame:WaitForChild("Speeds", 5)
        defaultWalk = speeds.Walk.Value

        if InfiniteStaminaEnabled and speeds then
            speeds.Walk.Value = speeds.Run.Value
        end
    end)
end

SetupStamina()
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    SetupStamina()
    CreateHitbox()
    UpdateHitbox()
end)

if LocalPlayer.Character then
    task.wait(1)
    CreateHitbox()
    UpdateHitbox()
end

-- Safe helpers for mobile dive buttons and firing them
function safeFindDiveButtons()
    local ok, gui = pcall(function()
        return LocalPlayer:FindFirstChild("PlayerGui")
    end)
    if not ok or not gui then return nil end

    local candidates = {
        {"MobileCTRL","TouchControlFrame","JumpButton"},
        {"MobileControls","TouchFrame","JumpBtn"},
        {"MobileCTRL","TouchControlFrame","DPad"},
    }

    for _, path in ipairs(candidates) do
        local node = gui
        for _, name in ipairs(path) do
            node = node and node:FindFirstChild(name)
            if not node then break end
        end
        if node then
            local left = node:FindFirstChild("LeftDive") or node:FindFirstChild("Left")
            local right = node:FindFirstChild("RightDive") or node:FindFirstChild("Right")
            if left and right then
                return left, right
            end
        end
    end

    return nil
end

function tryClick(btn)
    if not btn then return end
    pcall(function()
        if getconnections then
            local ok, conns = pcall(getconnections, btn.MouseButton1Click)
            if ok and type(conns) == 'table' and #conns > 0 and type(conns[1].Fire) == 'function' then
                conns[1]:Fire()
                return
            end
        end

        if btn.MouseButton1Click and type(btn.MouseButton1Click.Fire) == 'function' then
            btn.MouseButton1Click:Fire()
        end
    end)
end

-- Find the main jump button (for Space equivalents) on mobile
function safeFindJumpButton()
    local ok, gui = pcall(function()
        return LocalPlayer:FindFirstChild("PlayerGui")
    end)
    if not ok or not gui then return nil end

    local candidates = {
        {"MobileCTRL","TouchControlFrame","JumpButton"},
        {"MobileControls","TouchFrame","JumpBtn"},
    }

    for _, path in ipairs(candidates) do
        local node = gui
        for _, name in ipairs(path) do
            node = node and node:FindFirstChild(name)
            if not node then break end
        end
        if node then return node end
    end

    return nil
end

-- Decide whether to dive: fast shot heading to goal and not held by nearby player
function shouldDive(ballPart, ballPos, ballVel)
    if not ballPart or not ballPos or not ballVel then return false end
    local speed = ballVel.Magnitude
    if speed < 6 then return false end

    -- if ball heading to goal within short lookahead
    local heading = isBallHeadingToGoal(ballPart, ballVel, 2.2)
    if not heading then return false end

    -- if another player is very close to ball, assume contested
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") and pl ~= LocalPlayer then
            local d = (pl.Character.HumanoidRootPart.Position - ballPos).Magnitude
            if d < 2.5 then return false end
        end
    end

    return true
end

-- Check if player is near own goal. modeSeven flag selects 7v7 distances.
function isPlayerNearGoal(maxMode7)
    local root = GetRoot()
    if not root then return false end
    local bounds = findGoalBounds()
    if not bounds then return false end
    -- compute closest point on bounds to player
    local px, py, pz = root.Position.X, root.Position.Y, root.Position.Z
    local cx = math.clamp(px, bounds.min.X, bounds.max.X)
    local cy = math.clamp(py, bounds.min.Y, bounds.max.Y)
    local cz = math.clamp(pz, bounds.min.Z, bounds.max.Z)
    local dist = (Vector3.new(px,py,pz) - Vector3.new(cx,cy,cz)).Magnitude
    local thresh = maxMode7 and 40 or 25
    return dist <= thresh
end

-- Calculate dive direction string based on predicted landing point
function calculateDiveDirection(landingPos)
    local root = GetRoot()
    if not root or not landingPos then return "X" end
    local localPos = root.CFrame:PointToObjectSpace(landingPos)
    local right = localPos.X
    local up = localPos.Y
    local forward = localPos.Z

    -- aerials
    if up >= 6 then
        if right > 3 then return "E+Space" end
        if right < -3 then return "Q+Space" end
        return "Space"
    end

    -- medium height
    if up >= 2 and up < 6 then
        if math.abs(right) > 4 then return right > 0 and "E" or "Q" end
        return "X+Space"
    end

    -- low shots
    if math.abs(right) > 3 then return right > 0 and "E" or "Q" end
    if forward < 3 then return "X" end
    return "X"
end

-- Execute dive: mobile-first (buttons), fallback to PC virtual keys if available
function doDive(keyStr)
    if not keyStr then return end

    -- normalize
    keyStr = tostring(keyStr)
    local parts = {}
    for token in string.gmatch(keyStr, "[^%+]+") do table.insert(parts, token:match("^%s*(.-)%s*$")) end

    -- try mobile
    local leftBtn, rightBtn = safeFindDiveButtons()
    local jumpBtn = safeFindJumpButton()

    local function mobilePress(k)
        if k == "E" then tryClick(rightBtn)
        elseif k == "Q" then tryClick(leftBtn)
        elseif k == "X" then
            -- low dive: tap both quick to bias center
            tryClick(leftBtn); task.wait(0.02); tryClick(rightBtn)
        elseif k == "Space" then tryClick(jumpBtn)
        end
    end

    local mobileWorked = false
    if (leftBtn or rightBtn or jumpBtn) then
        for _, k in ipairs(parts) do pcall(function() mobilePress(k) end) end
        mobileWorked = true
    end

    if mobileWorked then return end

    -- Mobile-only: do not attempt PC key simulation.
    -- If mobile buttons were not found, there's nothing to do on this device.
end

local function safeLoadWindUI()
    local ok, lib = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"))()
    end)

    if ok and type(lib) == "table" then
        return lib
    end

    -- Minimal stub to avoid runtime errors when WindUI fails to load
    return setmetatable({}, {
        __index = function()
            return function() end
        end
    })
end

local WindUI = safeLoadWindUI()

if not WindUI or not WindUI.CreateWindow then
    warn("[VETA] WindUI failed to load - UI will not appear")
    return
end

local Window = WindUI:CreateWindow({
    Title = "RSS - VETA",
    Icon = "rbxassetid://106211849494703",
    Author = "Made By VETA",
    Folder = "RSSVETA",
})

local MainTab = Window:Tab({
    Title = "GK & Player Reach",
    Icon = "target",
})

local MainSection = MainTab:Section({
    Title = "Both Reach (Pretty Bad At GK)"
})

MainSection:Toggle({
    Title = "Enable Reach",
    Default = false,
    Callback = function(v)
        if v then
            EnableReach()
        else
            DisableReach()
        end
    end
})

MainSection:Toggle({
    Title = "Show Hitbox",
    Default = false,
    Callback = function(v)
        IsVisualizerEnabled = v
        UpdateHitbox()
    end
})

MainSection:Toggle({
    Title = "Performance Optimizer",
    Desc = "Disable particle effects / lights and pause predictor to reduce client lag",
    Default = false,
    Callback = function(v)
        ApplyOptimizations(v)
    end,
})

MainTab:Space()

local SizeSection = MainTab:Section({
    Title = "Hitbox Size (X/Y/Z)"
})

SizeSection:Slider({
    Title = "Size X",
    Step = 1,
    Value = {
        Min = 1,
        Max = 50,
        Default = 10,
    },
    Callback = function(v)
        HitboxSize = Vector3.new(v, HitboxSize.Y, HitboxSize.Z)
        UpdateHitbox()
    end
})

SizeSection:Slider({
    Title = "Size Y",
    Step = 1,
    Value = {
        Min = 1,
        Max = 50,
        Default = 10,
    },
    Callback = function(v)
        HitboxSize = Vector3.new(HitboxSize.X, v, HitboxSize.Z)
        UpdateHitbox()
    end
})

SizeSection:Slider({
    Title = "Size Z",
    Step = 1,
    Value = {
        Min = 1,
        Max = 50,
        Default = 10,
    },
    Callback = function(v)
        HitboxSize = Vector3.new(HitboxSize.X, HitboxSize.Y, v)
        UpdateHitbox()
    end
})

local GkTab = Window:Tab({
    Title = "GK Features",
    Icon = "rbxassetid://10734950020"
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local function isInFansTeam()
    return LocalPlayer.Team and LocalPlayer.Team.Name == "Fans"
end

local AutoPickSection = GkTab:Section({
    Title = "Auto Pick GK"
})

AutoPickSection:Dropdown({
    Title = "Game Mode",
    Desc = "Choose match mode (4v4 or 7v7)",
    Values = {"4v4", "7v7"},
    Value = "7v7",
    Multi = false,
    Callback = function(mode)
        PlayerGameMode = mode or "7v7"
        WindUI:Notify({Title = "Mode", Content = "Set to " .. PlayerGameMode, Icon = "target"})
    end
})

AutoPickSection:Dropdown({
    Title = "Choose Team",
    Desc = "USE THIS WHEN NO GK IN TEAM",
    Values = {"Home GK", "Away GK"},
    Value = nil,
    Multi = false,
    AllowNone = true,
    Callback = function(option)
        if not option or option == "" then
            return
        end
        
        if not isInFansTeam() then
            WindUI:Notify({
                Title = "Error",
                Icon = "ban",
                Content = "You must be in Fans/No Team to use this feature!",
                Duration = 5,
            })
            return
        end
        
        if option == "Home GK" then
            local args = {
                BrickColor.new(23),
                "Goalie"
            }
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(unpack(args))
        elseif option == "Away GK" then
            local args = {
                BrickColor.new(141),
                "Goalie"
            }
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(unpack(args))
        end
    end
})



local StaminaTab = Window:Tab({
    Title = "Infinite Stamina",
    Icon = "zap",
})

local StaminaSection = StaminaTab:Section({
    Title = "Infinite Stamina"
})

StaminaSection:Toggle({
    Title = "Enable Infinite Stamina",
    Default = false,
    Callback = function(v)
        getgenv().InfiniteStaminaEnabled = v
        if speeds then
            speeds.Walk.Value = v and speeds.Run.Value or defaultWalk
        end
    end
})

local PredictTab = Window:Tab({
    Title = "Ball Predictor",
    Icon = "circle",
})

local PredictSection = PredictTab:Section({
    Title = "Ball Predictor"
})

local predictionConnection = nil
local curveFolder = nil

PredictSection:Toggle({
    Title = "Enable Ball Predictor",
    Default = false,
    Callback = function(Value)
        if Value then
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local Workspace = game:GetService("Workspace")

            local config = {
                gravity = 196.2,
                bounceDamping = 0.68,
                groundHeight = 0,
                minBounceVelocity = 8,
                airResistance = 0.99,
                frictionCoefficient = 0.85,
                spinDecay = 0.95,
                magnusCoefficient = 0.00015,
                terminalVelocity = 200,
                rollingResistance = 0.92,
                
                segmentCount = 25,
                segmentSize = Vector3.new(0.3, 0.3, 2),
                segmentTransparency = 0.2,
                maxPredictionTime = 10,
                minVelocityThreshold = 3,
                simulationTimestep = 0.033,
                maxSimulationPoints = 80,
                updateRate = 3,
                
                colorCurve = Color3.fromRGB(0, 255, 0),
                colorLanding = Color3.fromRGB(0, 255, 0),
            }

            local vector3Zero = Vector3.zero
            local vector3Up = Vector3.new(0, 1, 0)
            local gravityVector = Vector3.new(0, -config.gravity, 0)

            local cachedBall = nil
            local lastBallCheck = 0
            local ballCheckInterval = 1

            local function getBall()
                -- Use the global GetBallData for consistency and caching
                return GetBallData()
            end

            curveFolder = Instance.new("Folder")
            curveFolder.Name = "BallPredictionCurve"
            curveFolder.Parent = workspace

            local segments = table.create(config.segmentCount)
            for i = 1, config.segmentCount do
                local segment = Instance.new("Part")
                segment.Name = "Segment_" .. i
                segment.Anchored = true
                segment.CanCollide = false
                segment.CastShadow = false
                segment.Material = Enum.Material.Neon
                segment.Transparency = config.segmentTransparency
                segment.Size = config.segmentSize
                segment.Color = config.colorCurve
                segment.Parent = curveFolder
                segments[i] = segment
            end

            local landingMarker = Instance.new("Part")
            landingMarker.Name = "LandingMarker"
            landingMarker.Anchored = true
            landingMarker.CanCollide = false
            landingMarker.CastShadow = false
            landingMarker.Material = Enum.Material.Neon
            landingMarker.Color = config.colorLanding
            landingMarker.Transparency = 0.4
            landingMarker.Size = Vector3.new(4, 0.2, 4)
            landingMarker.Shape = Enum.PartType.Cylinder
            landingMarker.Parent = curveFolder

            local landingRing = Instance.new("Part")
            landingRing.Name = "LandingRing"
            landingRing.Anchored = true
            landingRing.CanCollide = false
            landingRing.CastShadow = false
            landingRing.Material = Enum.Material.Neon
            landingRing.Color = config.colorLanding
            landingRing.Transparency = 0.6
            landingRing.Size = Vector3.new(6, 0.1, 6)
            landingRing.Shape = Enum.PartType.Cylinder
            landingRing.Parent = curveFolder

            local function simulateTrajectory(startPos, startVel)
                local points = table.create(config.maxSimulationPoints)
                local dt = config.simulationTimestep
                local maxTime = config.maxPredictionTime
                local gravityDt = gravityVector * dt
                local airResistance = config.airResistance ^ dt
                
                local pos = startPos
                local vel = startVel
                local time = 0
                local bounceCount = 0
                local pointCount = 0
                
                while time < maxTime and bounceCount < 8 and pointCount < config.maxSimulationPoints do
                    time = time + dt
                    pointCount = pointCount + 1
                    
                    vel = (vel + gravityDt) * airResistance
                    
                    if vel.Y < -config.terminalVelocity then
                        vel = Vector3.new(vel.X, -config.terminalVelocity, vel.Z)
                    end
                    
                    pos = pos + vel * dt
                    
                    points[pointCount] = {pos, vel, vel.Magnitude}
                    
                    if pos.Y <= config.groundHeight and vel.Y < 0 then
                        pos = Vector3.new(pos.X, config.groundHeight, pos.Z)
                        
                        local bounceVelY = -vel.Y * config.bounceDamping
                        vel = Vector3.new(
                            vel.X * config.frictionCoefficient,
                            bounceVelY,
                            vel.Z * config.frictionCoefficient
                        )
                        
                        bounceCount = bounceCount + 1
                        
                        if vel.Magnitude < config.minBounceVelocity then
                            points[pointCount] = {pos, vector3Zero, 0}
                            break
                        end
                    end
                    
                    if pos.Y < -500 or vel.Magnitude < 0.3 then
                        break
                    end
                end
                
                return points, pointCount
            end

            local function findFirstLanding(points, count)
                for i = 2, count do
                    local curr = points[i]
                    local prev = points[i-1]
                    local currPos, currVel = curr[1], curr[2]
                    local prevPos, prevVel = prev[1], prev[2]
                    
                    if currPos.Y <= config.groundHeight + 0.5 and 
                       prevPos.Y > config.groundHeight + 0.5 and
                       currVel.Y < 0 then
                        
                        local t = (config.groundHeight - prevPos.Y) / (currPos.Y - prevPos.Y)
                        t = math.clamp(t, 0, 1)
                        
                        return prevPos:Lerp(currPos, t), prevVel:Lerp(currVel, t)
                    end
                end
                return nil, nil
            end

            local frameCounter = 0
            local lastTrajectoryPoints = nil
            local lastPointCount = 0
            local lastLandingPos = nil
            local lastLandingVel = nil

            predictionConnection = RunService.Heartbeat:Connect(function()
                frameCounter = frameCounter + 1
                
                if frameCounter % config.updateRate ~= 0 then
                    return
                end
                
                local ball = getBall()
                if not ball then
                    for i = 1, config.segmentCount do
                        segments[i].Transparency = 1
                    end
                    landingMarker.Transparency = 1
                    landingRing.Transparency = 1
                    return
                end
                
                local velocity = ball.AssemblyLinearVelocity
                local speed = velocity.Magnitude
                
                if speed < config.minVelocityThreshold then
                    for i = 1, config.segmentCount do
                        segments[i].Transparency = 1
                    end
                    landingMarker.Transparency = 1
                    landingRing.Transparency = 1
                    return
                end
                
                local trajectoryPoints, pointCount = simulateTrajectory(ball.Position, velocity)
                lastTrajectoryPoints = trajectoryPoints
                lastPointCount = pointCount
                
                if pointCount > 1 then
                    local segmentStep = (pointCount - 1) / (config.segmentCount - 1)
                    
                    for i = 1, config.segmentCount do
                        local pointIndex = math.floor((i - 1) * segmentStep) + 1
                        local nextIndex = math.min(pointIndex + 1, pointCount)
                        
                        if pointIndex <= pointCount and nextIndex <= pointCount then
                            local current = trajectoryPoints[pointIndex]
                            local next = trajectoryPoints[nextIndex]
                            local currentPos, nextPos = current[1], next[1]
                            
                            local midpoint = (currentPos + nextPos) * 0.5
                            local distance = (nextPos - currentPos).Magnitude
                            
                            if distance > 0.01 then
                                local direction = (nextPos - currentPos) / distance
                                
                                segments[i].Size = Vector3.new(0.3, 0.3, distance)
                                segments[i].CFrame = CFrame.lookAt(midpoint, midpoint + direction)
                                segments[i].Transparency = config.segmentTransparency
                            else
                                segments[i].Transparency = 1
                            end
                        else
                            segments[i].Transparency = 1
                        end
                    end
                else
                    for i = 1, config.segmentCount do
                        segments[i].Transparency = 1
                    end
                end
                
                local landingPos, landingVel = findFirstLanding(trajectoryPoints, pointCount)
                lastLandingPos = landingPos
                lastLandingVel = landingVel
                
                if landingPos then
                    local markerPos = landingPos + Vector3.new(0, 0.1, 0)
                    landingMarker.CFrame = CFrame.new(markerPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                    landingMarker.Transparency = 0.4
                    
                    local ringPos = landingPos + Vector3.new(0, 0.05, 0)
                    landingRing.CFrame = CFrame.new(ringPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                    landingRing.Transparency = 0.6
                    
                    local pulse = math.sin(tick() * 5) * 0.5 + 0.5
                    local scale = 6 + pulse
                    landingRing.Size = Vector3.new(scale, 0.1, scale)
                else
                    landingMarker.Transparency = 1
                    landingRing.Transparency = 1
                end
            end)
        else
            if predictionConnection then
                predictionConnection:Disconnect()
                predictionConnection = nil
            end
            
            if curveFolder then
                curveFolder:Destroy()
                curveFolder = nil
            end
        end
    end
})
CreateHitbox()
UpdateHitbox()

-- Performance optimization: disable client-side heavy effects and optionally pause predictor/visuals
local OptimizationsApplied = false
local savedStates = {}
local wasPredictorEnabled = false

local function disableEffects()
    savedStates = {particles = {}, trails = {}, beams = {}, lights = {}, others = {}}
    -- Optimization: Use a larger batch size to reduce freeze time
    local count = 0
    local descendants = Workspace:GetDescendants()
    
    for _, obj in ipairs(descendants) do
        count = count + 1
        if count % 1000 == 0 then task.wait() end -- Process 1000 items per frame

        if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") or obj:IsA("Light") or obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
            pcall(function()
                if obj:IsA("ParticleEmitter") then
                    savedStates.particles[obj] = obj.Enabled
                    obj.Enabled = false
                elseif obj:IsA("Trail") then
                    savedStates.trails[obj] = obj.Enabled
                    obj.Enabled = false
                elseif obj:IsA("Beam") then
                    savedStates.beams[obj] = obj.Enabled
                    obj.Enabled = false
                elseif obj:IsA("Light") then
                    savedStates.lights[obj] = obj.Enabled
                    obj.Enabled = false
                elseif obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
                    savedStates.others[obj] = obj.Enabled
                    obj.Enabled = false
                end
            end)
        end
    end
    
    -- Lighting optimization
    pcall(function()
        local Lighting = game:GetService("Lighting")
        savedStates.lighting = {
            GlobalShadows = Lighting.GlobalShadows, 
            Brightness = Lighting.Brightness,
            FogEnd = Lighting.FogEnd
        }
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 9e9
    end)
end

local function restoreEffects()
    for obj, state in pairs(savedStates.particles or {}) do pcall(function() obj.Enabled = state end) end
    for obj, state in pairs(savedStates.trails or {}) do pcall(function() obj.Enabled = state end) end
    for obj, state in pairs(savedStates.beams or {}) do pcall(function() obj.Enabled = state end) end
    for obj, state in pairs(savedStates.lights or {}) do pcall(function() obj.Enabled = state end) end
    for obj, state in pairs(savedStates.others or {}) do pcall(function() obj.Enabled = state end) end
    if savedStates.lighting then
        pcall(function()
            local Lighting = game:GetService("Lighting")
            Lighting.GlobalShadows = savedStates.lighting.GlobalShadows
            Lighting.Brightness = savedStates.lighting.Brightness
            Lighting.FogEnd = savedStates.lighting.FogEnd
        end)
    end
    savedStates = {}
end

local function ApplyOptimizations(enable)
    if enable and not OptimizationsApplied then
        -- pause predictor if running
        if predictionConnection then
            wasPredictorEnabled = true
            pcall(function() predictionConnection:Disconnect() end)
            predictionConnection = nil
        else
            wasPredictorEnabled = false
        end

        disableEffects()
        -- hide heavy visuals
        IsVisualizerEnabled = false
        UpdateHitbox()
        OptimizationsApplied = true
        WindUI:Notify({Title = "Optimizer", Content = "Optimizations applied", Icon = "zap"})
    elseif not enable and OptimizationsApplied then
        restoreEffects()
        if wasPredictorEnabled then
            -- user can re-enable predictor via UI toggle; we avoid auto-starting to be safe
            WindUI:Notify({Title = "Optimizer", Content = "Predictor was running before; re-enable it from UI if needed", Icon = "info"})
        end
        OptimizationsApplied = false
        WindUI:Notify({Title = "Optimizer", Content = "Optimizations removed", Icon = "check"})
    end
end

local PlayerTab = Window:Tab({
    Title = "Player",
    Icon = "user",
})

local PlayerSection = PlayerTab:Section({
    Title = "Movement & Utilities"
})

PlayerSection:Slider({
    Title = "WalkSpeed",
    Step = 1,
    Value = {Min = 16, Max = 100, Default = 16},
    Callback = function(v)
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("Humanoid") then
            char.Humanoid.WalkSpeed = v
        end
    end
})

PlayerSection:Slider({
    Title = "JumpPower",
    Step = 1,
    Value = {Min = 50, Max = 200, Default = 50},
    Callback = function(v)
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("Humanoid") then
            char.Humanoid.UseJumpPower = true
            char.Humanoid.JumpPower = v
        end
    end
})

local AntiRagdollConn = nil
PlayerSection:Toggle({
    Title = "Anti-Ragdoll",
    Desc = "Prevents falling/stunning",
    Default = false,
    Callback = function(v)
        if v then
            local RunService = game:GetService("RunService")
            AntiRagdollConn = RunService.Stepped:Connect(function()
                local char = LocalPlayer.Character
                if char and char:FindFirstChild("Humanoid") then
                    char.Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
                    char.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
                    if char.Humanoid.PlatformStand then
                        char.Humanoid.PlatformStand = false
                    end
                end
            end)
        else
            if AntiRagdollConn then
                AntiRagdollConn:Disconnect()
                AntiRagdollConn = nil
            end
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("Humanoid") then
                char.Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
                char.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
            end
        end
    end
})

local BallCamConn = nil
PlayerSection:Toggle({
    Title = "Ball Camera",
    Desc = "Locks camera to ball",
    Default = false,
    Callback = function(v)
        if v then
            local RunService = game:GetService("RunService")
            BallCamConn = RunService.RenderStepped:Connect(function()
                local ball = FindBall()
                if ball and Workspace.CurrentCamera then
                    Workspace.CurrentCamera.CameraSubject = ball
                end
            end)
        else
            if BallCamConn then
                BallCamConn:Disconnect()
                BallCamConn = nil
            end
            if Workspace.CurrentCamera and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                Workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
            end
        end
    end
})

local Dialog = Window:Dialog({
    Icon = "bird",
    Title = "Hey!",
    Content = "Report To Our Discord If You Found Bugs/Glitches",
    Buttons = {
        {
            Title = "Continue",
            Callback = function()
                -- safe noop: CreateMainUI may not be defined in some environments
                if type(CreateMainUI) == "function" then
                    pcall(CreateMainUI)
                end
            end
        }
    }
})

-- Ensure CreateMainUI exists (some dialogs call it)
function CreateMainUI()
    -- intentionally minimal: if the real WindUI window init is elsewhere, this won't interfere
    pcall(function()
        WindUI:Notify({
            Title = "UI",
            Icon = "check",
            Content = "Main UI initialized",
            Duration = 2,
        })
    end)
end

WindUI:Notify({
    Title = "RSS Loaded",
    Icon = "check",
    Content = "RSS VETA Loaded Successfully"
})

local AdvancedGKSection = GkTab:Section({
    Title = "Auto GK V2 (Predictive)"
})

local GKSettings = {
    CloseDist = 15,
    FarDist = 35,
    Lookahead = 2.5,
    Cooldown = 0.5
}

AdvancedGKSection:Slider({
    Title = "Close Distance",
    Step = 1,
    Value = {Min = 5, Max = 30, Default = 15},
    Callback = function(v) GKSettings.CloseDist = v end
})

AdvancedGKSection:Slider({
    Title = "Far Distance",
    Step = 1,
    Value = {Min = 20, Max = 60, Default = 35},
    Callback = function(v) GKSettings.FarDist = v end
})

AdvancedGKSection:Slider({
    Title = "Lookahead Time",
    Step = 0.1,
    Value = {Min = 1, Max = 5, Default = 2.5},
    Callback = function(v) GKSettings.Lookahead = v end
})

AdvancedGKSection:Slider({
    Title = "Dive Cooldown",
    Step = 0.1,
    Value = {Min = 0.1, Max = 2, Default = 0.5},
    Callback = function(v) GKSettings.Cooldown = v end
})

AdvancedGKSection:Toggle({
    Title = "Enable Auto GK V2",
    Desc = "Predicts and dives towards ball landing",
    Default = false,
    Callback = function(enabled)
        local RunService = game:GetService("RunService")

        if getgenv().AutoGKV2Connection then
            pcall(function() getgenv().AutoGKV2Connection:Disconnect() end)
            getgenv().AutoGKV2Connection = nil
        end

        if not enabled then return end

        -- Ensure mutual exclusion: disable Auto Dive if it's running
        if getgenv().AutoDiveConnection then
            pcall(function() getgenv().AutoDiveConnection:Disconnect() end)
            getgenv().AutoDiveConnection = nil
            pcall(function() WindUI:Notify({Title = "Auto GK", Content = "Auto Dive disabled to avoid conflicts", Icon = "info"}) end)
        end
        getgenv().AutoGKMode = "V2"

        local STEP = 0.04
        local lastDive = 0
        local leftBtn, rightBtn = nil, nil
        local jumpBtn = nil -- Mobile jump button

        -- reuse button finder
        local function findButtonsLocal()
            local l, r = nil, nil
            if type(safeFindDiveButtons) == 'function' then
                l, r = safeFindDiveButtons()
            end
            
            -- Find mobile jump button
            local j = nil
            local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
            if playerGui then
                local touchGui = playerGui:FindFirstChild("TouchGui")
                if touchGui and touchGui:FindFirstChild("TouchControlFrame") then
                     j = touchGui.TouchControlFrame:FindFirstChild("JumpButton")
                end
            end
            
            return l, r, j
        end

        leftBtn, rightBtn, jumpBtn = findButtonsLocal()
        
        -- Listen for respawn to update buttons
        local function onRespawn()
             task.wait(1) -- wait for gui to load
             leftBtn, rightBtn, jumpBtn = findButtonsLocal()
        end
        
        local respawnConn = LocalPlayer.CharacterAdded:Connect(onRespawn)
        if getgenv().AutoGKV2Respawn then getgenv().AutoGKV2Respawn:Disconnect() end
        getgenv().AutoGKV2Respawn = respawnConn

        local function tryClickLocal(b)
            if not b then return end -- safety
            if type(tryClick) == 'function' then
                return tryClick(b)
            end
            pcall(function() if b and b.MouseButton1Click then b.MouseButton1Click:Fire() end end)
        end
        
        local function tryJump()
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("Humanoid") then
                char.Humanoid.Jump = true
            end
            -- Backup for mobile button
            if jumpBtn and jumpBtn.Parent then -- check if still exists
                 pcall(function() 
                    local pos = jumpBtn.AbsolutePosition
                    local size = jumpBtn.AbsoluteSize
                    local center = pos + size/2
                    game:GetService("VirtualInputManager"):SendTouchEvent(12345, 0, center.X, center.Y)
                    task.delay(0.1, function()
                         game:GetService("VirtualInputManager"):SendTouchEvent(12345, 1, center.X, center.Y)
                    end)
                 end)
            end
        end

        local function predictLanding(pos, vel)
            local g = Vector3.new(0, -196.2, 0)
            local p = pos
            local v = vel
            for t = 0, GKSettings.Lookahead, STEP do
                local dt = STEP
                v = v + g * dt
                p = p + v * dt
                if p.Y <= 3 then -- near ground
                    return p
                end
            end
            return nil
        end
        
        local function predictHighShot(pos, vel)
             local g = Vector3.new(0, -196.2, 0)
             local p = pos
             local v = vel
             -- Check peak height within lookahead
             for t = 0, GKSettings.Lookahead, STEP do
                 local dt = STEP
                 v = v + g * dt
                 p = p + v * dt
                 -- If ball is high (e.g. > 7 studs) and near goal
                 if p.Y > 7 and p.Y < 15 then 
                     return true, p
                 end
             end
             return false, nil
        end

        local lastAutoGKV2Check = 0
        getgenv().AutoGKV2Connection = RunService.Heartbeat:Connect(function()
            local now = tick()
            if now - lastAutoGKV2Check < 0.05 then return end -- throttle checks to ~20Hz (faster for 7v7)
            lastAutoGKV2Check = now

            local ball, bp, bv = GetBallData()
            if not ball or not bp then return end
            
            -- If buttons are missing, try to find them once
            if not leftBtn or not rightBtn then
                leftBtn, rightBtn, jumpBtn = findButtonsLocal()
            end

            local landing = predictLanding(bp, bv) or bp
            local heading, landingPos = isBallHeadingToGoal(ball, bv, GKSettings.Lookahead + 0.3)
            local isHigh, highPos = predictHighShot(bp, bv)
            
            local char = LocalPlayer.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            if not root then return end

            local targetPos = landingPos or landing
            local dist = (root.Position - targetPos).Magnitude
            
            if heading then
                -- Ball heading to goal
                if dist <= GKSettings.FarDist then
                    local now2 = tick()
                    if now2 - lastDive < GKSettings.Cooldown then return end
                    
                    local localPos = root.CFrame:PointToObjectSpace(targetPos)
                    
                    -- Smart High Dive Logic
                    if isHigh and highPos then
                        tryJump()
                        task.wait(0.1) -- small delay before dive
                    end

                    if localPos.X < 0 then
                        tryClickLocal(leftBtn)
                    else
                        tryClickLocal(rightBtn)
                    end
                    lastDive = now2
                end
            else
                -- Not heading to goal, but close
                if dist <= GKSettings.CloseDist then
                    local now2 = tick()
                    if now2 - lastDive < GKSettings.Cooldown then return end
                    
                    local localPos = root.CFrame:PointToObjectSpace(landing)
                    if localPos.X < 0 then
                        tryClickLocal(leftBtn)
                    else
                        tryClickLocal(rightBtn)
                    end
                    lastDive = now2
                end
            end
        end)
    end
})

local AssistSection = GkTab:Section({ Title = "Position Assist" })
local AssistLine = nil
local AssistUpdate = nil

AssistSection:Toggle({
    Title = "Enable Position Guide",
    Desc = "Green line shows optimal GK positioning",
    Default = false,
    Callback = function(v)
        if v then
            -- Create visual
            if not AssistLine then
                AssistLine = Instance.new("LineHandleAdornment")
                AssistLine.Name = "GKAssistLine"
                AssistLine.Color3 = Color3.fromRGB(0, 255, 100)
                AssistLine.Thickness = 5
                AssistLine.Transparency = 0.3
                AssistLine.AlwaysOnTop = true
                AssistLine.ZIndex = 5
                AssistLine.Parent = Workspace
            end
            
            local RunService = game:GetService("RunService")
            local lastCheck = 0
            local cachedGoalCenter = nil
            
            AssistUpdate = RunService.RenderStepped:Connect(function()
                local root = GetRoot()
                if not root then AssistLine.Visible = false return end
                
                -- Update goal center rarely
                if tick() - lastCheck > 2 or not cachedGoalCenter then
                    lastCheck = tick()
                    -- Find goal parts near player
                    local sumPos = Vector3.new(0,0,0)
                    local count = 0
                    local radius = 60
                    
                    -- Quick search in likely folders
                    local candidates = {}
                    local folders = {Workspace:FindFirstChild("Map"), Workspace:FindFirstChild("Goals")}
                    if #folders == 0 then folders = {Workspace} end
                    
                    for _, folder in ipairs(folders) do
                        if folder then
                            for _, p in ipairs(folder:GetDescendants()) do
                                if p:IsA("BasePart") then
                                    local ln = string.lower(p.Name)
                                    if (string.find(ln, "goal") or string.find(ln, "post")) and (p.Position - root.Position).Magnitude < radius then
                                        sumPos = sumPos + p.Position
                                        count = count + 1
                                    end
                                end
                            end
                        end
                    end
                    
                    if count > 0 then
                        cachedGoalCenter = sumPos / count
                    end
                end
                
                if cachedGoalCenter then
                    -- Ideal position: 5 studs towards field center from goal center
                    local fieldCenter = Vector3.new(0, cachedGoalCenter.Y, 0)
                    local dir = (fieldCenter - cachedGoalCenter).Unit
                    local ideal = cachedGoalCenter + dir * 6 -- Stand 6 studs out
                    -- keep Y at player level
                    ideal = Vector3.new(ideal.X, root.Position.Y, ideal.Z)
                    
                    AssistLine.Adornee = root
                    AssistLine.Length = (root.Position - ideal).Magnitude
                    AssistLine.CFrame = CFrame.lookAt(root.Position, ideal)
                    AssistLine.Visible = true
                    
                    if AssistLine.Length < 3 then
                         AssistLine.Color3 = Color3.fromRGB(0, 255, 0) -- Perfect
                    else
                         AssistLine.Color3 = Color3.fromRGB(255, 100, 0) -- Move!
                    end
                else
                    AssistLine.Visible = false
                end
            end)
        else
            if AssistUpdate then AssistUpdate:Disconnect() AssistUpdate = nil end
            if AssistLine then AssistLine:Destroy() AssistLine = nil end
        end
    end
})

Window:SetupWindow()
