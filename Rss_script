local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local HttpService = game:GetService("HttpService")
local LocalPlayer = Players.LocalPlayer
local ReachDistance = 1
local IsReachEnabled = false
local IsVisualizerEnabled = false
local HitboxSize = Vector3.new(10, 10, 10)
local ReachConnection = nil
local Ball = nil
local RSSHitbox = nil
getgenv().InfiniteStaminaEnabled = false

local function IsMobileDevice()
    return UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
end

local function SafeHttpGet(url)
    local ok, res = pcall(function()
        if typeof(game.HttpGet) == "function" then
            return game:HttpGet(url)
        end
        return HttpService:GetAsync(url)
    end)
    if ok then
        return res
    end
end

local function SafeActivateButton(btn)
    if not btn then return false end
    local ok = pcall(function()
        if typeof(getconnections) == "function" and btn.MouseButton1Click then
            local connections = getconnections(btn.MouseButton1Click)
            if connections and #connections > 0 then
                connections[1]:Fire()
                return
            end
        end

        if btn.Activate then
            btn:Activate()
            return
        end

        if btn.MouseButton1Click then
            btn.MouseButton1Click:Fire()
        end
    end)
    return ok
end

local function SafeFind(instance, path)
    local current = instance
    for _, name in ipairs(path) do
        if not current then return nil end
        current = current:FindFirstChild(name)
    end
    return current
end

local function CreateHitbox()
    if RSSHitbox then RSSHitbox:Destroy() end

    RSSHitbox = Instance.new("BoxHandleAdornment")
    RSSHitbox.Name = "RSSHitbox"
    RSSHitbox.AlwaysOnTop = false
    RSSHitbox.ZIndex = 10
    RSSHitbox.Color3 = Color3.fromRGB(0, 255, 0)
    RSSHitbox.Transparency = 1
    RSSHitbox.Size = HitboxSize
    RSSHitbox.Adornee = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    RSSHitbox.Parent = Workspace.Terrain

    local Glow = Instance.new("BoxHandleAdornment")
    Glow.Name = "Glow"
    Glow.AlwaysOnTop = true
    Glow.ZIndex = 0
    Glow.Color3 = Color3.fromRGB(0, 255, 100)
    Glow.Transparency = 1
    Glow.Size = HitboxSize * 1
    Glow.Parent = RSSHitbox
end

local function UpdateHitbox()
    if not RSSHitbox then return end
    
    RSSHitbox.Size = HitboxSize
    local Glow = RSSHitbox:FindFirstChild("Glow")
    if Glow then 
        Glow.Size = HitboxSize * 1
    end

    local shouldShow = IsReachEnabled and IsVisualizerEnabled
    
    RSSHitbox.Transparency = shouldShow and 0.8 or 1
    if Glow then 
        Glow.Transparency = shouldShow and 0.7 or 1
    end
end

local function GetRoot() 
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end

local function FindBall()
    local b = Workspace:FindFirstChild("ball")
    if b and b:IsA("BasePart") then return b end
end

local CachedTouchParts = {}
local function RefreshTouchParts()
    table.clear(CachedTouchParts)
    local character = LocalPlayer.Character
    if not character then return end

    local function addPart(name)
        local p = character:FindFirstChild(name)
        if p and p:IsA("BasePart") then
            table.insert(CachedTouchParts, p)
        end
    end

    addPart("HumanoidRootPart")
    addPart("LeftFoot")
    addPart("RightFoot")
    addPart("LeftHand")
    addPart("RightHand")

    if #CachedTouchParts == 0 then
        for _, part in character:GetChildren() do
            if part:IsA("BasePart") then
                table.insert(CachedTouchParts, part)
            end
        end
    end
end

local function ReachLoop()
    local root = GetRoot()
    if not root or not RSSHitbox then return end

    RSSHitbox.Adornee = root
    local Glow = RSSHitbox:FindFirstChild("Glow")
    if Glow then Glow.Adornee = root end

    local ball = FindBall()
    if not ball then return end

    local baseReach = math.max(HitboxSize.X, HitboxSize.Y, HitboxSize.Z) / 2
    local velocity = ball.AssemblyLinearVelocity or Vector3.new()
    local speed = velocity.Magnitude
    local dynamicBonus = math.clamp(speed * 0.06, 0, baseReach * 1.2)
    local effectiveReach = (baseReach + dynamicBonus) * ReachDistance

    local predictionTime = 0.14
    local predictedPos = ball.Position + velocity * predictionTime

    if (predictedPos - root.Position).Magnitude <= effectiveReach then
        if typeof(firetouchinterest) == "function" then
            if #CachedTouchParts == 0 then
                RefreshTouchParts()
            end
            for _, part in ipairs(CachedTouchParts) do
                if part and part.Parent then
                    firetouchinterest(part, ball, 0)
                    task.wait()
                    firetouchinterest(part, ball, 1)
                end
            end
        end
    end
end

local function EnableReach()
    if ReachConnection then return end
    IsReachEnabled = true
    UpdateHitbox()
    ReachConnection = RunService.Heartbeat:Connect(ReachLoop)
end

local function DisableReach()
    if ReachConnection then 
        ReachConnection:Disconnect() 
        ReachConnection = nil 
    end
    IsReachEnabled = false
    UpdateHitbox()
end

local speeds = nil
local defaultWalk = 16

local function SetupStamina()
    pcall(function()
        local gui = LocalPlayer:WaitForChild("PlayerGui", 10)
        local stamina = gui:WaitForChild("Stamina", 10)
        local frame = stamina:WaitForChild("Frame", 5)
        speeds = frame:WaitForChild("Speeds", 5)
        defaultWalk = speeds.Walk.Value

        if getgenv().InfiniteStaminaEnabled and speeds then
            speeds.Walk.Value = speeds.Run.Value
        end
    end)
end

SetupStamina()
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    SetupStamina()
    RefreshTouchParts()
end)

RefreshTouchParts()

local function SetReachEnabled(v)
    if v then
        EnableReach()
    else
        DisableReach()
    end
end

local function SetInfiniteStaminaEnabled(v)
    getgenv().InfiniteStaminaEnabled = v
    if speeds then
        speeds.Walk.Value = v and speeds.Run.Value or defaultWalk
    end
end

local function FireDiveRemote(direction)
    local remotes = ReplicatedStorage:FindFirstChild("Remotes")
    if remotes then
        local diveRemote = remotes:FindFirstChild("Dive")
        if diveRemote and diveRemote:IsA("RemoteEvent") then
            diveRemote:FireServer(direction)
            return true
        end
    end
    return false
end

local function BindHotkeys()
    if IsMobileDevice() then return end

    ContextActionService:UnbindAction("RSS_ToggleReach")
    ContextActionService:UnbindAction("RSS_ToggleVisualizer")
    ContextActionService:UnbindAction("RSS_ToggleStamina")

    ContextActionService:BindAction("RSS_ToggleReach", function(_, state)
        if state ~= Enum.UserInputState.Begin then return end
        SetReachEnabled(not IsReachEnabled)
    end, false, Enum.KeyCode.R)

    ContextActionService:BindAction("RSS_ToggleVisualizer", function(_, state)
        if state ~= Enum.UserInputState.Begin then return end
        IsVisualizerEnabled = not IsVisualizerEnabled
        UpdateHitbox()
    end, false, Enum.KeyCode.H)

    ContextActionService:BindAction("RSS_ToggleStamina", function(_, state)
        if state ~= Enum.UserInputState.Begin then return end
        SetInfiniteStaminaEnabled(not getgenv().InfiniteStaminaEnabled)
    end, false, Enum.KeyCode.T)

    ContextActionService:BindAction("RSS_DiveLeft", function(_, state)
        if state ~= Enum.UserInputState.Begin then return end
        FireDiveRemote("Left")
    end, false, Enum.KeyCode.Q)

    ContextActionService:BindAction("RSS_DiveRight", function(_, state)
        if state ~= Enum.UserInputState.Begin then return end
        FireDiveRemote("Right")
    end, false, Enum.KeyCode.E)
end

BindHotkeys()

local WindUI
do
    local src = SafeHttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua")
    if src and typeof(loadstring) == "function" then
        local ok, lib = pcall(function()
            return loadstring(src)()
        end)
        if ok then
            WindUI = lib
        end
    end
end

local function Notify(payload)
    if WindUI and WindUI.Notify then
        pcall(function()
            WindUI:Notify(payload)
        end)
        return
    end
end

local Window = WindUI and WindUI:CreateWindow({
    Title = "RSS - VETA",
    Icon = "rbxassetid://106211849494703",
    Author = "Made By VETA",
    Folder = "RSSVETA",
})

if not RSSHitbox then
    CreateHitbox()
end
UpdateHitbox()

if Window then

local MainTab = Window:Tab({
    Title = "GK & Player Reach",
    Icon = "target",
})

local MainSection = MainTab:Section({
    Title = "Both Reach (Pretty Bad At GK)"
})

MainSection:Toggle({
    Title = "Enable Reach",
    Default = false,
    Callback = function(v)
        SetReachEnabled(v)
    end
})

MainSection:Toggle({
    Title = "Show Hitbox",
    Default = false,
    Callback = function(v)
        IsVisualizerEnabled = v
        UpdateHitbox()
    end
})

MainTab:Space()

local SizeSection = MainTab:Section({
    Title = "Hitbox Size (X/Y/Z)"
})

SizeSection:Slider({
    Title = "Size X",
    Step = 1,
    Value = {
        Min = 1,
        Max = 50,
        Default = 10,
    },
    Callback = function(v)
        HitboxSize = Vector3.new(v, HitboxSize.Y, HitboxSize.Z)
        UpdateHitbox()
    end
})

SizeSection:Slider({
    Title = "Size Y",
    Step = 1,
    Value = {
        Min = 1,
        Max = 50,
        Default = 10,
    },
    Callback = function(v)
        HitboxSize = Vector3.new(HitboxSize.X, v, HitboxSize.Z)
        UpdateHitbox()
    end
})

SizeSection:Slider({
    Title = "Size Z",
    Step = 1,
    Value = {
        Min = 1,
        Max = 50,
        Default = 10,
    },
    Callback = function(v)
        HitboxSize = Vector3.new(HitboxSize.X, HitboxSize.Y, v)
        UpdateHitbox()
    end
})

SizeSection:Slider({
    Title = "Reach Multiplier",
    Step = 0.1,
    Value = {
        Min = 1,
        Max = 5,
        Default = 1,
    },
    Callback = function(v)
        ReachDistance = v
    end
})

local GkTab = Window:Tab({
    Title = "GK Features",
    Icon = "rbxassetid://10734950020"
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local function isInFansTeam()
    return LocalPlayer.Team and LocalPlayer.Team.Name == "Fans"
end

local AutoPickSection = GkTab:Section({
    Title = "Auto Pick GK"
})

AutoPickSection:Dropdown({
    Title = "Choose Team",
    Desc = "USE THIS WHEN NO GK IN TEAM",
    Values = {"Home GK", "Away GK"},
    Value = nil,
    Multi = false,
    AllowNone = true,
    Callback = function(option)
        if not option or option == "" then
            return
        end
        
        if not isInFansTeam() then
            WindUI:Notify({
                Title = "Error",
                Icon = "ban",
                Content = "You must be in Fans/No Team to use this feature!",
                Duration = 5,
            })
            return
        end
        
        if option == "Home GK" then
            local args = {
                BrickColor.new(23),
                "Goalie"
            }
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(unpack(args))
        elseif option == "Away GK" then
            local args = {
                BrickColor.new(141),
                "Goalie"
            }
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(unpack(args))
        end
    end
})

local LegacyDiveSection = GkTab:Section({
        Title = "Auto Dive"
    })

local DiveSection = GkTab:Section({
    Title = "Auto Dive (Improved)"
})

local DiveToggle = DiveSection:Toggle({
    Title = "Auto Dive [PREDICTION]",
    Desc = "Smart Auto-GK with Velocity Prediction",
    Default = false,
    Callback = function(enabled)
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")

        local LocalPlayer = Players.LocalPlayer
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

        if getgenv().AutoDiveConnection then
            getgenv().AutoDiveConnection:Disconnect()
            getgenv().AutoDiveConnection = nil
        end

        if not enabled then return end

        local DIVE_DISTANCE = 16
        local DIVE_COOLDOWN = 0.8
        local BASE_PREDICTION_TIME = 0.25
        local MAX_PREDICTION_TIME = 0.6
        local PREDICTION_SPEED_FACTOR = 0.012
        local MIN_BALL_SPEED = 6
        local SPIN_INFLUENCE = 0.04
        local LAG_DISTANCE_MULTIPLIER = 1.25

        local lastDiveTime = 0
        local leftDiveButton = nil
        local rightDiveButton = nil
        local jumpButtonRef = nil

        local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
        local mobileCTRL = playerGui and playerGui:FindFirstChild("MobileCTRL")
        local touchControlFrame = mobileCTRL and mobileCTRL:FindFirstChild("TouchControlFrame")
        local jumpButton = touchControlFrame and touchControlFrame:FindFirstChild("JumpButton")
        jumpButtonRef = jumpButton
        leftDiveButton = jumpButton and jumpButton:FindFirstChild("LeftDive")
        rightDiveButton = jumpButton and jumpButton:FindFirstChild("RightDive")

        local function autoDive(predictedPos)
            local currentTime = tick()

            if currentTime - lastDiveTime < DIVE_COOLDOWN then return end

            local playerCFrame = HumanoidRootPart.CFrame
            local localBallPos = playerCFrame:PointToObjectSpace(predictedPos)

            if localBallPos.X < -1 then
                if leftDiveButton then
                    SafeActivateButton(leftDiveButton)
                    lastDiveTime = currentTime
                else
                    if FireDiveRemote("Left") then
                        lastDiveTime = currentTime
                    end
                end
            elseif localBallPos.X > 1 then
                if rightDiveButton then
                    SafeActivateButton(rightDiveButton)
                    lastDiveTime = currentTime
                else
                    if FireDiveRemote("Right") then
                        lastDiveTime = currentTime
                    end
                end
            else
                if jumpButtonRef then
                    SafeActivateButton(jumpButtonRef)
                    lastDiveTime = currentTime
                else
                    if FireDiveRemote("Center") then
                        lastDiveTime = currentTime
                    end
                end
            end
        end

        getgenv().AutoDiveConnection = RunService.Heartbeat:Connect(function(dt)
            local ball = workspace:FindFirstChild("ball") or workspace:FindFirstChild("TPS") or workspace:FindFirstChild("PSoccerBall")
            if not ball then return end

            local velocity = ball.AssemblyLinearVelocity
            local speed = velocity.Magnitude
            if speed < MIN_BALL_SPEED then return end

            local predictionTime = BASE_PREDICTION_TIME + speed * PREDICTION_SPEED_FACTOR
            predictionTime = math.clamp(predictionTime, BASE_PREDICTION_TIME, MAX_PREDICTION_TIME)

            local predictedPosition = ball.Position + (velocity * predictionTime)

            local angular = ball.AssemblyAngularVelocity
            local spinStrength = angular.Magnitude
            if spinStrength > 0 then
                local forward = velocity.Magnitude > 0 and velocity.Unit or (HumanoidRootPart.Position - ball.Position).Unit
                local side = forward:Cross(Vector3.new(0, 1, 0))
                if side.Magnitude > 0 then
                    side = side.Unit
                    local spinOffset = side * spinStrength * SPIN_INFLUENCE
                    predictedPosition = predictedPosition + spinOffset
                end
            end

            local distance = (HumanoidRootPart.Position - predictedPosition).Magnitude
            local currentDist = (HumanoidRootPart.Position - ball.Position).Magnitude

            local effectiveDiveDistance = DIVE_DISTANCE
            if dt and dt > 0.02 then
                effectiveDiveDistance = effectiveDiveDistance * LAG_DISTANCE_MULTIPLIER
            end

            if distance <= effectiveDiveDistance and distance < currentDist then
                autoDive(predictedPosition, effectiveDiveDistance - distance)
            end
        end)
    end
})

local StaminaTab = Window:Tab({
    Title = "Infinite Stamina",
    Icon = "zap",
})

local StaminaSection = StaminaTab:Section({
    Title = "Infinite Stamina"
})

StaminaSection:Toggle({
    Title = "Enable Infinite Stamina",
    Default = false,
    Callback = function(v)
        SetInfiniteStaminaEnabled(v)
    end
})

local PredictTab = Window:Tab({
    Title = "Ball Predictor",
    Icon = "circle",
})

local PredictSection = PredictTab:Section({
    Title = "Ball Predictor"
})

local predictionConnection = nil
local curveFolder = nil

PredictSection:Toggle({
    Title = "Enable Ball Predictor",
    Default = false,
    Callback = function(Value)
        if Value then
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local Workspace = game:GetService("Workspace")

            local config = {
                gravity = 196.2,
                bounceDamping = 0.68,
                groundHeight = 0,
                minBounceVelocity = 8,
                airResistance = 0.99,
                frictionCoefficient = 0.85,
                spinDecay = 0.95,
                magnusCoefficient = 0.00015,
                terminalVelocity = 200,
                rollingResistance = 0.92,
                
                segmentCount = 25,
                segmentSize = Vector3.new(0.3, 0.3, 2),
                segmentTransparency = 0.2,
                maxPredictionTime = 10,
                minVelocityThreshold = 3,
                simulationTimestep = 0.033,
                maxSimulationPoints = 80,
                updateRate = 3,
                
                colorCurve = Color3.fromRGB(0, 255, 0),
                colorLanding = Color3.fromRGB(0, 255, 0),
            }

            local vector3Zero = Vector3.zero
            local vector3Up = Vector3.new(0, 1, 0)
            local gravityVector = Vector3.new(0, -config.gravity, 0)

            local cachedBall = nil
            local lastBallCheck = 0
            local ballCheckInterval = 1

            local function getBall()
                local now = tick()
                if cachedBall and cachedBall.Parent and now - lastBallCheck < ballCheckInterval then
                    return cachedBall
                end
                
                lastBallCheck = now
                cachedBall = Workspace:FindFirstChild("TPS", true) 
                    or Workspace:FindFirstChild("PSoccerBall", true)
                    or Workspace:FindFirstChild("ball", true)
                
                return cachedBall
            end

            curveFolder = Instance.new("Folder")
            curveFolder.Name = "BallPredictionCurve"
            curveFolder.Parent = workspace

            local segments = table.create(config.segmentCount)
            for i = 1, config.segmentCount do
                local segment = Instance.new("Part")
                segment.Name = "Segment_" .. i
                segment.Anchored = true
                segment.CanCollide = false
                segment.CastShadow = false
                segment.Material = Enum.Material.Neon
                segment.Transparency = config.segmentTransparency
                segment.Size = config.segmentSize
                segment.Color = config.colorCurve
                segment.Parent = curveFolder
                segments[i] = segment
            end

            local landingMarker = Instance.new("Part")
            landingMarker.Name = "LandingMarker"
            landingMarker.Anchored = true
            landingMarker.CanCollide = false
            landingMarker.CastShadow = false
            landingMarker.Material = Enum.Material.Neon
            landingMarker.Color = config.colorLanding
            landingMarker.Transparency = 0.4
            landingMarker.Size = Vector3.new(4, 0.2, 4)
            landingMarker.Shape = Enum.PartType.Cylinder
            landingMarker.Parent = curveFolder

            local landingRing = Instance.new("Part")
            landingRing.Name = "LandingRing"
            landingRing.Anchored = true
            landingRing.CanCollide = false
            landingRing.CastShadow = false
            landingRing.Material = Enum.Material.Neon
            landingRing.Color = config.colorLanding
            landingRing.Transparency = 0.6
            landingRing.Size = Vector3.new(6, 0.1, 6)
            landingRing.Shape = Enum.PartType.Cylinder
            landingRing.Parent = curveFolder

            local function simulateTrajectory(startPos, startVel)
            local points = table.create(config.maxSimulationPoints)
                local dt = config.simulationTimestep
                local maxTime = config.maxPredictionTime
                local gravityDt = gravityVector * dt
                local airResistance = config.airResistance ^ dt
                
                local pos = startPos
                local vel = startVel
                local time = 0
                local bounceCount = 0
                local pointCount = 0
                
                while time < maxTime and bounceCount < 8 and pointCount < config.maxSimulationPoints do
                    time = time + dt
                    pointCount = pointCount + 1
                    
                    vel = (vel + gravityDt) * airResistance
                    
                    if vel.Y < -config.terminalVelocity then
                        vel = Vector3.new(vel.X, -config.terminalVelocity, vel.Z)
                    end
                    
                    pos = pos + vel * dt
                    
                    points[pointCount] = {pos, vel, vel.Magnitude}
                    
                    if pos.Y <= config.groundHeight and vel.Y < 0 then
                        pos = Vector3.new(pos.X, config.groundHeight, pos.Z)
                        
                        local bounceVelY = -vel.Y * config.bounceDamping
                        vel = Vector3.new(
                            vel.X * config.frictionCoefficient,
                            bounceVelY,
                            vel.Z * config.frictionCoefficient
                        )
                        
                        bounceCount = bounceCount + 1
                        
                        if vel.Magnitude < config.minBounceVelocity then
                            points[pointCount] = {pos, vector3Zero, 0}
                            break
                        end
                    end
                    
                    if pos.Y < -500 or vel.Magnitude < 0.3 then
                        break
                    end
                end
                
                return points, pointCount
            end

            local function findFirstLanding(points, count)
                for i = 2, count do
                    local curr = points[i]
                    local prev = points[i-1]
                    local currPos, currVel = curr[1], curr[2]
                    local prevPos, prevVel = prev[1], prev[2]
                    
                    if currPos.Y <= config.groundHeight + 0.5 and 
                       prevPos.Y > config.groundHeight + 0.5 and
                       currVel.Y < 0 then
                        
                        local t = (config.groundHeight - prevPos.Y) / (currPos.Y - prevPos.Y)
                        t = math.clamp(t, 0, 1)
                        
                        return prevPos:Lerp(currPos, t), prevVel:Lerp(currVel, t)
                    end
                end
                return nil, nil
            end

            local frameCounter = 0
            local lastTrajectoryPoints = nil
            local lastPointCount = 0
            local lastLandingPos = nil
            local lastLandingVel = nil

            predictionConnection = RunService.Heartbeat:Connect(function()
                frameCounter = frameCounter + 1
                
                if frameCounter % config.updateRate ~= 0 then
                    return
                end
                
                local ball = getBall()
                if not ball then
                    for i = 1, config.segmentCount do
                        segments[i].Transparency = 1
                    end
                    landingMarker.Transparency = 1
                    landingRing.Transparency = 1
                    return
                end
                
                local velocity = ball.AssemblyLinearVelocity
                local speed = velocity.Magnitude
                
                if speed < config.minVelocityThreshold then
                    for i = 1, config.segmentCount do
                        segments[i].Transparency = 1
                    end
                    landingMarker.Transparency = 1
                    landingRing.Transparency = 1
                    return
                end
                
                local trajectoryPoints, pointCount = simulateTrajectory(ball.Position, velocity)
                lastTrajectoryPoints = trajectoryPoints
                lastPointCount = pointCount
                
                if pointCount > 1 then
                    local segmentStep = (pointCount - 1) / (config.segmentCount - 1)
                    
                    for i = 1, config.segmentCount do
                        local pointIndex = math.floor((i - 1) * segmentStep) + 1
                        local nextIndex = math.min(pointIndex + 1, pointCount)
                        
                        if pointIndex <= pointCount and nextIndex <= pointCount then
                            local current = trajectoryPoints[pointIndex]
                            local next = trajectoryPoints[nextIndex]
                            local currentPos, nextPos = current[1], next[1]
                            
                            local midpoint = (currentPos + nextPos) * 0.5
                            local distance = (nextPos - currentPos).Magnitude
                            
                            if distance > 0.01 then
                                local direction = (nextPos - currentPos) / distance
                                
                                segments[i].Size = Vector3.new(0.3, 0.3, distance)
                                segments[i].CFrame = CFrame.lookAt(midpoint, midpoint + direction)
                                segments[i].Transparency = config.segmentTransparency
                            else
                                segments[i].Transparency = 1
                            end
                        else
                            segments[i].Transparency = 1
                        end
                    end
                else
                    for i = 1, config.segmentCount do
                        segments[i].Transparency = 1
                    end
                end
                
                local landingPos, landingVel = findFirstLanding(trajectoryPoints, pointCount)
                lastLandingPos = landingPos
                lastLandingVel = landingVel
                
                if landingPos then
                    local markerPos = landingPos + Vector3.new(0, 0.1, 0)
                    landingMarker.CFrame = CFrame.new(markerPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                    landingMarker.Transparency = 0.4
                    
                    local ringPos = landingPos + Vector3.new(0, 0.05, 0)
                    landingRing.CFrame = CFrame.new(ringPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                    landingRing.Transparency = 0.6
                    
                    local pulse = math.sin(tick() * 5) * 0.5 + 0.5
                    local scale = 6 + pulse
                    landingRing.Size = Vector3.new(scale, 0.1, scale)
                else
                    landingMarker.Transparency = 1
                    landingRing.Transparency = 1
                end
            end)
        else
            if predictionConnection then
                predictionConnection:Disconnect()
                predictionConnection = nil
            end
            
            if curveFolder then
                curveFolder:Destroy()
                curveFolder = nil
            end
        end
    end
})

if not RSSHitbox then
    CreateHitbox()
end
UpdateHitbox()

local ControlsTab = Window:Tab({
    Title = "Controls",
    Icon = "keyboard",
})

local ControlsSection = ControlsTab:Section({
    Title = "PC / Mobile Support"
})

local CreateMainUI

ControlsSection:Button({
    Title = "Rebind Hotkeys (PC)",
    Desc = "R=Reach, H=Hitbox, T=Stamina, Q/E=Dive",
    Callback = function()
        BindHotkeys()
        Notify({
            Title = "Controls",
            Icon = "check",
            Content = "Hotkeys bound: R, H, T, Q, E",
            Duration = 4,
        })
    end
})

ControlsSection:Button({
    Title = "Open Mobile Panel",
    Desc = "Touch buttons for phone/tablet",
    Callback = function()
        CreateMainUI()
    end
})

local PlayerTab = Window:Tab({
    Title = "Player",
    Icon = "user",
})

local PlayerSection = PlayerTab:Section({
    Title = "Soon."
})

CreateMainUI = function()
    local gui = LocalPlayer:FindFirstChild("PlayerGui")
    if not gui then return end

    local existing = gui:FindFirstChild("RSSVETA_MainUI")
    if existing then
        existing.Enabled = true
        return
    end

    local screen = Instance.new("ScreenGui")
    screen.Name = "RSSVETA_MainUI"
    screen.ResetOnSpawn = false
    screen.Parent = gui

    local scale = Instance.new("UIScale")
    scale.Scale = IsMobileDevice() and 1.05 or 1
    scale.Parent = screen

    local hint = Instance.new("TextLabel")
    hint.BackgroundTransparency = 0.35
    hint.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    hint.TextColor3 = Color3.fromRGB(255, 255, 255)
    hint.TextWrapped = true
    hint.TextXAlignment = Enum.TextXAlignment.Left
    hint.TextYAlignment = Enum.TextYAlignment.Top
    hint.Font = Enum.Font.Gotham
    hint.TextSize = IsMobileDevice() and 14 or 12
    hint.Size = UDim2.new(0, IsMobileDevice() and 320 or 360, 0, IsMobileDevice() and 120 or 90)
    hint.Position = UDim2.new(0, 12, 0, 12)
    hint.Text = IsMobileDevice() and "Mobile: use on-screen buttons (if your game provides them)." or "PC: R=Reach, H=Hitbox, T=Stamina, Q/E=Dive"
    hint.Parent = screen

    if IsMobileDevice() then
        local panel = Instance.new("Frame")
        panel.Name = "MobilePanel"
        panel.BackgroundTransparency = 0.25
        panel.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        panel.BorderSizePixel = 0
        panel.Size = UDim2.new(0, 220, 0, 220)
        panel.Position = UDim2.new(1, -232, 1, -232)
        panel.Parent = screen

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 10)
        corner.Parent = panel

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 10)
        padding.PaddingBottom = UDim.new(0, 10)
        padding.PaddingLeft = UDim.new(0, 10)
        padding.PaddingRight = UDim.new(0, 10)
        padding.Parent = panel

        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Vertical
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Padding = UDim.new(0, 8)
        layout.Parent = panel

        local function makeButton(name)
            local b = Instance.new("TextButton")
            b.Name = name
            b.AutoButtonColor = true
            b.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
            b.BorderSizePixel = 0
            b.Size = UDim2.new(1, 0, 0, 32)
            b.Font = Enum.Font.GothamSemibold
            b.TextSize = 14
            b.TextColor3 = Color3.fromRGB(255, 255, 255)
            local c = Instance.new("UICorner")
            c.CornerRadius = UDim.new(0, 8)
            c.Parent = b
            b.Parent = panel
            return b
        end

        local btnReach = makeButton("Reach")
        local btnHitbox = makeButton("Hitbox")
        local btnStamina = makeButton("Stamina")
        local btnDiveL = makeButton("DiveLeft")
        local btnDiveR = makeButton("DiveRight")
        local btnClose = makeButton("Close")

        local function refreshText()
            btnReach.Text = IsReachEnabled and "Reach: ON" or "Reach: OFF"
            btnHitbox.Text = IsVisualizerEnabled and "Hitbox: ON" or "Hitbox: OFF"
            btnStamina.Text = getgenv().InfiniteStaminaEnabled and "Stamina: ON" or "Stamina: OFF"
            btnDiveL.Text = "Dive: Left"
            btnDiveR.Text = "Dive: Right"
            btnClose.Text = "Close"
        end

        btnReach.MouseButton1Click:Connect(function()
            SetReachEnabled(not IsReachEnabled)
            refreshText()
        end)

        btnHitbox.MouseButton1Click:Connect(function()
            IsVisualizerEnabled = not IsVisualizerEnabled
            UpdateHitbox()
            refreshText()
        end)

        btnStamina.MouseButton1Click:Connect(function()
            SetInfiniteStaminaEnabled(not getgenv().InfiniteStaminaEnabled)
            refreshText()
        end)

        btnDiveL.MouseButton1Click:Connect(function()
            FireDiveRemote("Left")
        end)

        btnDiveR.MouseButton1Click:Connect(function()
            FireDiveRemote("Right")
        end)

        btnClose.MouseButton1Click:Connect(function()
            screen.Enabled = false
        end)

        refreshText()
    end
end

local Dialog = Window:Dialog({
    Icon = "bird",
    Title = "Hey!",
    Content = "Report To Our Discord If You Found Bugs/Glitches",
    Buttons = {
        {
            Title = "Continue",
            Callback = function()
                CreateMainUI()
            end
        }
    }
})

Notify({
    Title = "RSS Loaded",
    Icon = "check",
    Content = "Loaded successfully",
    Duration = 4,
})

end
