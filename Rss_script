local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer

-- ===== CONFIGURATION =====
local ReachDistance = 1
local IsReachEnabled = false
local IsVisualizerEnabled = false
local HitboxSize = Vector3.new(10, 10, 10)
local ReachConnection = nil
local RSSHitbox = nil

getgenv().InfiniteStaminaEnabled = false
-- Сброс старых соединений при перезапуске
if getgenv().AutoDiveConnection then getgenv().AutoDiveConnection:Disconnect() end
if getgenv().GKV2_CONNECTION then getgenv().GKV2_CONNECTION:Disconnect() end

-- ===== GLOBAL UTILITY FUNCTIONS =====
local function GetActiveBall()
    local ballNames = {"ball", "TPS", "PSoccerBall"}
    for _, name in ipairs(ballNames) do
        local b = Workspace:FindFirstChild(name)
        if b and b:IsA("BasePart") then return b end
    end
    return nil
end

local function ClickButton(btn)
    if not btn then return false end
    if typeof(getconnections) == "function" and btn.MouseButton1Click then
        local connections = getconnections(btn.MouseButton1Click)
        if connections and #connections > 0 then
            connections[1]:Fire()
            return true
        end
    end
    btn.MouseButton1Click:Fire()
    return true
end

local function TryJump(direction)
    direction = direction or "Center"
    
    -- ПК: VirtualInputManager (Эмуляция клавиш)
    pcall(function()
        if direction == "Center" or direction == "Upper" or direction == "Low" then
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
            task.wait(0.05)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
        elseif direction == "Left" or direction == "UpperLeft" then
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
            task.wait(0.05)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
        elseif direction == "Right" or direction == "UpperRight" then
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.05)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
        end
    end)
    
    -- Мобайл: Touch кнопки
    pcall(function()
        local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
        if not playerGui then return end
        local mobileCTRL = playerGui:FindFirstChild("MobileCTRL")
        if not mobileCTRL then return end
        local touchControlFrame = mobileCTRL:FindFirstChild("TouchControlFrame")
        if not touchControlFrame then return end
        local jumpButton = touchControlFrame:FindFirstChild("JumpButton")
        if not jumpButton then return end
        
        if direction == "Center" or direction == "Upper" or direction == "Low" then
            ClickButton(jumpButton)
        elseif direction == "Left" or direction == "UpperLeft" then
            local leftDive = jumpButton:FindFirstChild("LeftDive")
            if leftDive then ClickButton(leftDive) end
        elseif direction == "Right" or direction == "UpperRight" then
            local rightDive = jumpButton:FindFirstChild("RightDive")
            if rightDive then ClickButton(rightDive) end
        end
    end)
end

-- ===== HITBOX SYSTEM =====
pcall(function()
    if Workspace.Terrain:FindFirstChild("RSSHitbox") then
        Workspace.Terrain.RSSHitbox:Destroy()
    end
end)

local function CreateHitbox()
    if RSSHitbox then RSSHitbox:Destroy() end

    RSSHitbox = Instance.new("BoxHandleAdornment")
    RSSHitbox.Name = "RSSHitbox"
    RSSHitbox.AlwaysOnTop = true
    RSSHitbox.ZIndex = 10
    RSSHitbox.Color3 = Color3.fromRGB(0, 200, 255)
    RSSHitbox.Transparency = 1
    RSSHitbox.Size = HitboxSize
    RSSHitbox.Adornee = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    RSSHitbox.Parent = Workspace.Terrain

    local InnerGlow = Instance.new("BoxHandleAdornment")
    InnerGlow.Name = "InnerGlow"
    InnerGlow.Parent = RSSHitbox
    InnerGlow.Size = HitboxSize * 0.8
    InnerGlow.Color3 = Color3.fromRGB(100, 255, 200)
    InnerGlow.Transparency = 1
    InnerGlow.AlwaysOnTop = true
    InnerGlow.ZIndex = 5

    local OuterGlow = Instance.new("BoxHandleAdornment")
    OuterGlow.Name = "OuterGlow"
    OuterGlow.Parent = RSSHitbox
    OuterGlow.Size = HitboxSize * 1.3
    OuterGlow.Color3 = Color3.fromRGB(0, 255, 100)
    OuterGlow.Transparency = 1
    OuterGlow.AlwaysOnTop = true
    OuterGlow.ZIndex = 2
end

local function UpdateHitbox()
    if not RSSHitbox then return end
    
    RSSHitbox.Size = HitboxSize
    local InnerGlow = RSSHitbox:FindFirstChild("InnerGlow")
    local OuterGlow = RSSHitbox:FindFirstChild("OuterGlow")
    
    if InnerGlow then InnerGlow.Size = HitboxSize * 0.8 end
    if OuterGlow then OuterGlow.Size = HitboxSize * 1.3 end

    local shouldShow = IsReachEnabled and IsVisualizerEnabled
    
    if shouldShow then
        local pulse = math.sin(tick() * 3) * 0.3 + 0.5
        RSSHitbox.Transparency = 0.3 + (pulse * 0.4)
        if InnerGlow then InnerGlow.Transparency = 0.4 + (pulse * 0.3) end
        if OuterGlow then OuterGlow.Transparency = 0.6 + (pulse * 0.2) end
    else
        RSSHitbox.Transparency = 1
        if InnerGlow then InnerGlow.Transparency = 1 end
        if OuterGlow then OuterGlow.Transparency = 1 end
    end
end

local function GetRoot() 
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end

local function ReachLoop()
    local root = GetRoot()
    if not root or not RSSHitbox then return end

    RSSHitbox.Adornee = root
    local InnerGlow = RSSHitbox:FindFirstChild("InnerGlow")
    local OuterGlow = RSSHitbox:FindFirstChild("OuterGlow")
    if InnerGlow then InnerGlow.Adornee = root end
    if OuterGlow then OuterGlow.Adornee = root end

    local ball = GetActiveBall()
    if not ball then return end

    local touchParts = {
        root,
        LocalPlayer.Character:FindFirstChild("LeftUpperLeg"),
        LocalPlayer.Character:FindFirstChild("RightUpperLeg"),
        LocalPlayer.Character:FindFirstChild("LeftLowerLeg"),
        LocalPlayer.Character:FindFirstChild("RightLowerLeg"),
        LocalPlayer.Character:FindFirstChild("LeftFoot"),
        LocalPlayer.Character:FindFirstChild("RightFoot"),
    }

    local effectiveReach = math.max(HitboxSize.X, HitboxSize.Y, HitboxSize.Z) / 2

    if (ball.Position - root.Position).Magnitude <= effectiveReach then
        for _, part in ipairs(touchParts) do
            if part and part:IsA("BasePart") then
                firetouchinterest(part, ball, 0)
                firetouchinterest(part, ball, 1)
            end
        end
    end
end

local function EnableReach()
    if ReachConnection then return end
    IsReachEnabled = true
    UpdateHitbox()
    ReachConnection = RunService.Heartbeat:Connect(ReachLoop)
end

local function DisableReach()
    if ReachConnection then 
        ReachConnection:Disconnect() 
        ReachConnection = nil 
    end
    IsReachEnabled = false
    UpdateHitbox()
end

-- ===== STAMINA =====
local speeds = nil
local defaultWalk = 16

local function SetupStamina()
    pcall(function()
        local gui = LocalPlayer:WaitForChild("PlayerGui", 5)
        if not gui then return end
        local stamina = gui:WaitForChild("Stamina", 5)
        if not stamina then return end
        local frame = stamina:WaitForChild("Frame", 5)
        speeds = frame:WaitForChild("Speeds", 5)
        defaultWalk = speeds.Walk.Value

        if InfiniteStaminaEnabled and speeds then
            speeds.Walk.Value = speeds.Run.Value
        end
    end)
end

SetupStamina()
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    SetupStamina()
    CreateHitbox()
end)

-- ===== UI SETUP =====
local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "RSS - VETA (Fixed)",
    Icon = "rbxassetid://106211849494703",
    Author = "Made By VETA",
    Folder = "RSSVETA",
})

local MainTab = Window:Tab({ Title = "GK & Player Reach", Icon = "target" })
local MainSection = MainTab:Section({ Title = "Both Reach" })

MainSection:Toggle({
    Title = "Enable Reach",
    Default = false,
    Callback = function(v)
        if v then EnableReach() else DisableReach() end
    end
})

MainSection:Toggle({
    Title = "Show Hitbox",
    Default = false,
    Callback = function(v)
        IsVisualizerEnabled = v
        UpdateHitbox()
    end
})

MainTab:Space()
local SizeSection = MainTab:Section({ Title = "Hitbox Size (X/Y/Z)" })

local function UpdateHitboxSize(axis, value)
    if axis == "X" then HitboxSize = Vector3.new(value, HitboxSize.Y, HitboxSize.Z)
    elseif axis == "Y" then HitboxSize = Vector3.new(HitboxSize.X, value, HitboxSize.Z)
    elseif axis == "Z" then HitboxSize = Vector3.new(HitboxSize.X, HitboxSize.Y, value)
    end
    UpdateHitbox()
end

SizeSection:Slider({ Title = "Size X", Step = 1, Value = {Min = 1, Max = 50, Default = 10}, Callback = function(v) UpdateHitboxSize("X", v) end })
SizeSection:Slider({ Title = "Size Y", Step = 1, Value = {Min = 1, Max = 50, Default = 10}, Callback = function(v) UpdateHitboxSize("Y", v) end })
SizeSection:Slider({ Title = "Size Z", Step = 1, Value = {Min = 1, Max = 50, Default = 10}, Callback = function(v) UpdateHitboxSize("Z", v) end })

-- ===== GK FEATURES =====
local GkTab = Window:Tab({ Title = "GK Features", Icon = "rbxassetid://10734950020" })

local AutoPickSection = GkTab:Section({ Title = "Auto Pick GK" })
AutoPickSection:Dropdown({
    Title = "Choose Team",
    Desc = "Must be in Fans/No Team",
    Values = {"Home GK", "Away GK"},
    AllowNone = true,
    Callback = function(option)
        if not option then return end
        if LocalPlayer.Team and LocalPlayer.Team.Name ~= "Fans" then
            WindUI:Notify({Title = "Error", Icon = "ban", Content = "Must be in Fans/No Team!", Duration = 3})
            return
        end
        local teamColor = (option == "Home GK") and BrickColor.new(23) or BrickColor.new(141)
        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(teamColor, "Goalie")
    end
})

-- GK Variables
local GKV2_ENABLED = false
local GKV2_MIN_BALL_SPEED = 8
local GKV2_NEAR_GOAL_DISTANCE_4v4 = 25
local GKV2_NEAR_GOAL_DISTANCE_7v7 = 45
local GKV2_DIVE_COOLDOWN = 0.45
local GKV2_DETECTION_DISTANCE = 40
local GK_GOAL_Z_POSITION = -150

local DIVE_DISTANCE_REGULAR = 25
local DIVE_COOLDOWN_REGULAR = 0.45
local PREDICTION_TIME_REGULAR = 0.18
local MIN_BALL_SPEED_REGULAR = 7

-- GK Logic Functions
local function isBallHeadingToGoal(ball, playerPos)
    local ballVel = ball.AssemblyLinearVelocity
    local ballSpeed = ballVel.Magnitude
    if ballSpeed < GKV2_MIN_BALL_SPEED then return false end
    
    local ballToGoal = (Vector3.new(playerPos.X, playerPos.Y, GK_GOAL_Z_POSITION) - ball.Position)
    return ballVel:Dot(ballToGoal.Unit) > ballSpeed * 0.3
end

local function isPlayerNearGoal(playerPos)
    local goalPos = Vector3.new(playerPos.X, 5, GK_GOAL_Z_POSITION)
    local distance = (playerPos - goalPos).Magnitude
    local gameMode = math.abs(playerPos.X) < 30 and "4v4" or "7v7"
    return distance <= (gameMode == "7v7" and GKV2_NEAR_GOAL_DISTANCE_7v7 or GKV2_NEAR_GOAL_DISTANCE_4v4)
end

local function calculateDiveDirection(ball, playerCFrame)
    local ballPos = ball.Position
    local ballVel = ball.AssemblyLinearVelocity
    local ballSpeed = ballVel.Magnitude
    
    local predictionTime = math.clamp(0.1 + (ballSpeed / 100), 0.1, 0.3)
    local predictedPos = ballPos + ballVel * predictionTime
    local localBallPos = playerCFrame:PointToObjectSpace(predictedPos)
    
    local dirX = localBallPos.X
    local dirY = localBallPos.Y
    
    local highThreshold = ballSpeed > 20 and 3 or 4
    local sideThreshold = ballSpeed > 20 and 1.5 or 2.5
    
    if dirY > highThreshold then
        if dirX < -sideThreshold then return "UpperLeft"
        elseif dirX > sideThreshold then return "UpperRight"
        else return "Upper" end
    elseif dirY < -1 then
        return "Low"
    else
        if dirX < -sideThreshold then return "Left"
        elseif dirX > sideThreshold then return "Right"
        else return "Center" end
    end
end

-- GK UI Sections
local DetectionSection = GkTab:Section({ Title = "Settings" })
DetectionSection:Slider({ Title = "Ball Detection (V1)", Step = 1, Value = {Min = 15, Max = 40, Default = 25}, Callback = function(v) DIVE_DISTANCE_REGULAR = v end })
DetectionSection:Slider({ Title = "Ball Detection (V2)", Step = 1, Value = {Min = 20, Max = 60, Default = 40}, Callback = function(v) GKV2_DETECTION_DISTANCE = v end })
DetectionSection:Slider({ Title = "Cooldown", Step = 0.05, Value = {Min = 0.3, Max = 1.0, Default = 0.45}, Callback = function(v) DIVE_COOLDOWN_REGULAR = v; GKV2_DIVE_COOLDOWN = v end })

local GKV2Section = GkTab:Section({ Title = "Auto GK V2 (Advanced)" })

-- Toggles with Mutual Exclusion
local V1_Toggle_Func = nil
local V2_Toggle_Func = nil

V2_Toggle_Func = GKV2Section:Toggle({
    Title = "Enable Auto GK V2",
    Desc = "Smart direction prediction",
    Default = false,
    Callback = function(enabled)
        GKV2_ENABLED = enabled
        
        if getgenv().GKV2_CONNECTION then getgenv().GKV2_CONNECTION:Disconnect() end
        
        -- Conflict: Disable V1 if enabled
        if enabled and getgenv().AutoDiveConnection then
           -- Note: WindUI doesn't easily let us programmatically toggle the UI switch to false visually without a reference, 
           -- but we can disconnect the logic.
           getgenv().AutoDiveConnection:Disconnect()
           getgenv().AutoDiveConnection = nil
           WindUI:Notify({Title = "Mode Switch", Content = "Disabled Auto Dive V1 to run V2", Duration = 2})
        end

        if not enabled then return end
        
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
        local lastDiveTime = 0
        
        getgenv().GKV2_CONNECTION = RunService.Heartbeat:Connect(function()
            if not GKV2_ENABLED then return end
            
            local ball = GetActiveBall()
            if not ball then return end
            
            local playerPos = HumanoidRootPart.Position
            local ballVel = ball.AssemblyLinearVelocity
            local ballSpeed = ballVel.Magnitude
            
            if ballSpeed < GKV2_MIN_BALL_SPEED then return end
            if not isBallHeadingToGoal(ball, playerPos) then return end
            if not isPlayerNearGoal(playerPos) then return end
            if (playerPos - ball.Position).Magnitude > GKV2_DETECTION_DISTANCE then return end
            
            if tick() - lastDiveTime < GKV2_DIVE_COOLDOWN then return end
            
            TryJump(calculateDiveDirection(ball, HumanoidRootPart.CFrame))
            lastDiveTime = tick()
        end)
    end
})

local DiveSection = GkTab:Section({ Title = "Auto Dive (V1)" })
V1_Toggle_Func = DiveSection:Toggle({
    Title = "Enable Auto Dive V1",
    Desc = "Simple prediction",
    Default = false,
    Callback = function(enabled)
        if getgenv().AutoDiveConnection then getgenv().AutoDiveConnection:Disconnect() end
        
        -- Conflict: Disable V2 if enabled
        if enabled and GKV2_ENABLED then
            GKV2_ENABLED = false
            if getgenv().GKV2_CONNECTION then getgenv().GKV2_CONNECTION:Disconnect() end
            WindUI:Notify({Title = "Mode Switch", Content = "Disabled Auto GK V2 to run V1", Duration = 2})
        end

        if not enabled then return end

        local HumanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local lastDiveTime = 0

        getgenv().AutoDiveConnection = RunService.Heartbeat:Connect(function()
            local ball = GetActiveBall()
            if not ball then return end
            
            HumanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not HumanoidRootPart then return end
            
            local ballPos = ball.Position
            local ballVel = ball.AssemblyLinearVelocity
            local ballSpeed = ballVel.Magnitude
            
            if ballSpeed < MIN_BALL_SPEED_REGULAR then return end
            
            local distance = (HumanoidRootPart.Position - ballPos).Magnitude
            if distance <= DIVE_DISTANCE_REGULAR and distance > 1 then
                if tick() - lastDiveTime >= DIVE_COOLDOWN_REGULAR then
                    -- Simple Smart Dive Logic
                    local predicted = ballPos + ballVel * PREDICTION_TIME_REGULAR
                    local localPos = HumanoidRootPart.CFrame:PointToObjectSpace(predicted)
                    local dirX, dirY = localPos.X, localPos.Y
                    
                    if ballSpeed > 20 then
                        if dirY > 3 then TryJump(dirX < -1 and "Left" or (dirX > 1 and "Right" or "Upper"))
                        elseif dirY < -2 then TryJump("Center")
                        else TryJump(dirX < -0.5 and "Left" or (dirX > 0.5 and "Right" or "Center")) end
                    else
                        TryJump(dirX < -1 and "Left" or (dirX > 1 and "Right" or "Center"))
                    end
                    lastDiveTime = tick()
                end
            end
        end)
    end
})

-- ===== STAMINA & PREDICTOR =====
local StaminaTab = Window:Tab({ Title = "Stamina & Extras", Icon = "zap" })
local StaminaSection = StaminaTab:Section({ Title = "Infinite Stamina" })
StaminaSection:Toggle({
    Title = "Enable",
    Default = false,
    Callback = function(v)
        getgenv().InfiniteStaminaEnabled = v
        if speeds then speeds.Walk.Value = v and speeds.Run.Value or defaultWalk end
    end
})

local PredictSection = StaminaTab:Section({ Title = "Ball Predictor" })
local predictionConnection = nil
local curveFolder = nil

PredictSection:Toggle({
    Title = "Enable Predictor",
    Default = false,
    Callback = function(Value)
        if predictionConnection then predictionConnection:Disconnect() predictionConnection = nil end
        if curveFolder then curveFolder:Destroy() curveFolder = nil end
        
        if not Value then return end

        local config = {
            segmentCount = 20,
            colorCurve = Color3.fromRGB(0, 255, 0),
            gravity = Vector3.new(0, -196.2, 0)
        }
        
        curveFolder = Instance.new("Folder", Workspace)
        curveFolder.Name = "BallPredictionCurve"
        
        local segments = {}
        for i=1, config.segmentCount do
            local p = Instance.new("Part", curveFolder)
            p.Anchored, p.CanCollide, p.CastShadow = true, false, false
            p.Material = Enum.Material.Neon
            p.Color = config.colorCurve
            p.Size = Vector3.new(0.3, 0.3, 1)
            segments[i] = p
        end

        predictionConnection = RunService.Heartbeat:Connect(function()
            local ball = GetActiveBall()
            if not ball then 
                for _, s in ipairs(segments) do s.Transparency = 1 end
                return 
            end
            
            local pos, vel = ball.Position, ball.AssemblyLinearVelocity
            if vel.Magnitude < 2 then 
                 for _, s in ipairs(segments) do s.Transparency = 1 end
                 return 
            end

            local dt = 0.05
            for i=1, config.segmentCount do
                local nextPos = pos + vel * dt + 0.5 * config.gravity * dt * dt
                vel = vel + config.gravity * dt
                
                local seg = segments[i]
                local dist = (nextPos - pos).Magnitude
                seg.Size = Vector3.new(0.3, 0.3, dist)
                seg.CFrame = CFrame.lookAt((pos + nextPos)/2, nextPos)
                seg.Transparency = 0.3
                
                pos = nextPos
                if pos.Y < 0 then break end -- Ground check
            end
        end)
    end
})

CreateHitbox()
UpdateHitbox()

WindUI:Notify({
    Title = "RSS Loaded",
    Icon = "check",
    Content = "Cleaned version loaded!"
})
