-- ============================================
-- RSS - VETA –£–ª—É—á—à–µ–Ω–Ω—ã–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è —Ñ—É—Ç–±–æ–ª–∞ v3
-- ============================================

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- –ö–æ–Ω—Ñ–∏–≥–∏
local CONFIG = {
    DEFAULT_REACH = 10,
    MAX_REACH = 50,
    DIVE_DISTANCE = 10.3,
    DIVE_COOLDOWN = 0.7,
    BALL_NAMES = {"ball", "TPS", "PSoccerBall", "Ball", "SoccerBall"},
    GRAVITY = 196.2,
}

-- –ê–í–¢–û–°–û–•–†–ê–ù–ï–ù–ò–ï –ò –ó–ê–ì–†–£–ó–ö–ê –ù–ê–°–¢–†–û–ï–ö
local SaveSystem = {
    SaveKey = "RSS_VETA_v3_Settings",
    DefaultSettings = {
        ReachEnabled = false,
        ReachX = 10,
        ReachY = 10,
        ReachZ = 10,
        VisualizerEnabled = false,
        InfiniteStaminaEnabled = false,
        AutoDiveEnabled = false,
        BallPredictorEnabled = false,
        DiveDistance = 15,
        DiveReactionTime = 0.6,
        BallVelocityThreshold = 8,
    }
}

local function LoadSettings()
    local success, data = pcall(function()
        return game:GetService("HttpService"):JSONDecode(readfile(SaveSystem.SaveKey .. ".json") or "{}") or SaveSystem.DefaultSettings
    end)
    return success and data or SaveSystem.DefaultSettings
end

local function SaveSettings(settings)
    pcall(function()
        writefile(SaveSystem.SaveKey .. ".json", game:GetService("HttpService"):JSONEncode(settings))
    end)
end

-- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
local State = {
    IsReachEnabled = false,
    IsVisualizerEnabled = false,
    HitboxSize = Vector3.new(CONFIG.DEFAULT_REACH, CONFIG.DEFAULT_REACH, CONFIG.DEFAULT_REACH),
    ReachConnection = nil,
    RSSHitbox = nil,
    InfiniteStaminaEnabled = false,
}

getgenv().InfiniteStaminaEnabled = false

-- –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
local SavedSettings = LoadSettings()

-- –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∫ State
State.IsReachEnabled = SavedSettings.ReachEnabled
State.IsVisualizerEnabled = SavedSettings.VisualizerEnabled
State.InfiniteStaminaEnabled = SavedSettings.InfiniteStaminaEnabled
State.HitboxSize = Vector3.new(
    SavedSettings.ReachX or CONFIG.DEFAULT_REACH,
    SavedSettings.ReachY or CONFIG.DEFAULT_REACH,
    SavedSettings.ReachZ or CONFIG.DEFAULT_REACH
)

-- ============ –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –°–û–•–†–ê–ù–ï–ù–ò–Ø ============

local function UpdateAndSaveSettings(key, value)
    SavedSettings[key] = value
    SaveSettings(SavedSettings)
end

-- ============ –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ============

local function Notify(title, content, icon)
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = title,
            Text = content,
            Icon = icon == "check" and "rbxassetid://6031075938" or "rbxassetid://6031068426",
            Duration = 3,
        })
    end)
end

local function GetRoot()
    local character = LocalPlayer.Character
    if not character then return nil end
    return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso")
end

local function FindBall()
    for _, name in pairs(CONFIG.BALL_NAMES) do
        local ball = Workspace:FindFirstChild(name)
        if ball and ball:IsA("BasePart") then
            return ball
        end
        
        -- –ü–æ–∏—Å–∫ –≤ –ø–∞–ø–∫–∞—Ö
        for _, folder in pairs(Workspace:GetChildren()) do
            if folder:IsA("Folder") or folder:IsA("Model") then
                local foundBall = folder:FindFirstChild(name)
                if foundBall and foundBall:IsA("BasePart") then
                    return foundBall
                end
            end
        end
    end
    return nil
end

local function IsGoalkeeper()
    local character = LocalPlayer.Character
    if not character then return false end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–º–∞–Ω–¥—É
    if not LocalPlayer.Team then return false end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–æ–ª—å —á–µ—Ä–µ–∑ GUI –∏–ª–∏ –¥—Ä—É–≥–∏–µ –º–µ—Ç–æ–¥—ã
    pcall(function()
        local playerGui = LocalPlayer:WaitForChild("PlayerGui", 2)
        local roleGui = playerGui:FindFirstChild("Role") or playerGui:FindFirstChild("Position")
        if roleGui then
            local roleText = roleGui:FindFirstChildOfClass("TextLabel")
            if roleText and string.find(roleText.Text:lower(), "goal") then
                return true
            end
        end
    end)
    
    return true -- –í—Ä–µ–º–µ–Ω–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º true –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
end

-- ============ REACH –°–ò–°–¢–ï–ú–ê ============

local function CreateHitbox()
    if State.RSSHitbox then State.RSSHitbox:Destroy() end

    local root = GetRoot()
    if not root then return end

    State.RSSHitbox = Instance.new("BoxHandleAdornment")
    State.RSSHitbox.Name = "RSSHitbox"
    State.RSSHitbox.AlwaysOnTop = false
    State.RSSHitbox.ZIndex = 10
    State.RSSHitbox.Color3 = Color3.fromRGB(0, 255, 0)
    State.RSSHitbox.Transparency = 1
    State.RSSHitbox.Size = State.HitboxSize
    State.RSSHitbox.Adornee = root
    State.RSSHitbox.Parent = Workspace.Terrain

    local Glow = Instance.new("BoxHandleAdornment")
    Glow.Name = "Glow"
    Glow.AlwaysOnTop = true
    Glow.ZIndex = 0
    Glow.Color3 = Color3.fromRGB(0, 255, 100)
    Glow.Transparency = 1
    Glow.Size = State.HitboxSize
    Glow.Parent = State.RSSHitbox
end

local function UpdateHitbox()
    if not State.RSSHitbox then CreateHitbox() return end
    
    State.RSSHitbox.Size = State.HitboxSize
    local Glow = State.RSSHitbox:FindFirstChild("Glow")
    if Glow then 
        Glow.Size = State.HitboxSize
        Glow.Transparency = (State.IsReachEnabled and State.IsVisualizerEnabled) and 0.7 or 1
    end
end

local function ReachLoop()
    local root = GetRoot()
    if not root or not State.RSSHitbox then return end

    State.RSSHitbox.Adornee = root
    local Glow = State.RSSHitbox:FindFirstChild("Glow")
    if Glow then Glow.Adornee = root end

    local ball = FindBall()
    if not ball then return end

    local effectiveReach = math.max(State.HitboxSize.X, State.HitboxSize.Y, State.HitboxSize.Z) / 2

    if (ball.Position - root.Position).Magnitude <= effectiveReach then
        local character = LocalPlayer.Character
        if character then
            for _, part in character:GetChildren() do
                if part:IsA("BasePart") then
                    pcall(function()
                        firetouchinterest(part, ball, 0)
                        task.wait()
                        firetouchinterest(part, ball, 1)
                    end)
                end
            end
        end
    end
end

local function EnableReach()
    if State.ReachConnection then return end
    State.IsReachEnabled = true
    CreateHitbox()
    UpdateHitbox()
    State.ReachConnection = RunService.Heartbeat:Connect(ReachLoop)
    UpdateAndSaveSettings("ReachEnabled", true)
    Notify("Reach", "Reach –≤–∫–ª—é—á–µ–Ω ‚úì", "check")
end

local function DisableReach()
    if State.ReachConnection then 
        State.ReachConnection:Disconnect() 
        State.ReachConnection = nil 
    end
    State.IsReachEnabled = false
    UpdateHitbox()
    UpdateAndSaveSettings("ReachEnabled", false)
    Notify("Reach", "Reach –≤—ã–∫–ª—é—á–µ–Ω ‚úó", "ban")
end
-- ============ STAMINA –°–ò–°–¢–ï–ú–ê ============

local speeds = nil
local defaultWalk = 16

local function SetupStamina()
    pcall(function()
        local gui = LocalPlayer:WaitForChild("PlayerGui", 10)
        local stamina = gui:WaitForChild("Stamina", 10)
        local frame = stamina:WaitForChild("Frame", 5)
        speeds = frame:WaitForChild("Speeds", 5)
        defaultWalk = speeds.Walk.Value
    end)
end

local function UpdateStamina()
    if speeds then
        speeds.Walk.Value = State.InfiniteStaminaEnabled and speeds.Run.Value or defaultWalk
    end
end

SetupStamina()
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    SetupStamina()
    UpdateStamina()
    if State.IsReachEnabled then
        CreateHitbox()
    end
end)

-- ============ UI –ó–ê–ì–†–£–ó–ö–ê ============

local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "RSS - VETA v3",
    Icon = "rbxassetid://106211849494703",
    Author = "–£–ª—É—á—à–µ–Ω–Ω—ã–π —Å–∫—Ä–∏–ø—Ç —Å —Ñ–∏–∫—Å–∞–º–∏",
    Folder = "RSSVETA",
})

-- ============ MAIN TAB ============
local MainTab = Window:Tab({
    Title = "üéØ Reach",
    Icon = "target",
})

local ReachSection = MainTab:Section({
    Title = "–û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"
})

ReachSection:Toggle({
    Title = "–í–∫–ª—é—á–∏—Ç—å Reach",
    Default = SavedSettings.ReachEnabled,
    Callback = function(v)
        if v then EnableReach() else DisableReach() end
    end
})

ReachSection:Toggle({
    Title = "–ü–æ–∫–∞–∑–∞—Ç—å —Ö–∏—Ç–±–æ–∫—Å",
    Default = SavedSettings.VisualizerEnabled,
    Callback = function(v)
        State.IsVisualizerEnabled = v
        UpdateAndSaveSettings("VisualizerEnabled", v)
        UpdateHitbox()
    end
})

MainTab:Space()

local SizeSection = MainTab:Section({
    Title = "–†–∞–∑–º–µ—Ä—ã —Ö–∏—Ç–±–æ–∫—Å–∞ (X/Y/Z)"
})

SizeSection:Slider({
    Title = "–†–∞–∑–º–µ—Ä X",
    Step = 1,
    Value = {Min = 1, Max = CONFIG.MAX_REACH, Default = SavedSettings.ReachX or CONFIG.DEFAULT_REACH},
    Callback = function(v)
        State.HitboxSize = Vector3.new(v, State.HitboxSize.Y, State.HitboxSize.Z)
        UpdateAndSaveSettings("ReachX", v)
        UpdateHitbox()
    end
})

SizeSection:Slider({
    Title = "–†–∞–∑–º–µ—Ä Y",
    Step = 1,
    Value = {Min = 1, Max = CONFIG.MAX_REACH, Default = SavedSettings.ReachY or CONFIG.DEFAULT_REACH},
    Callback = function(v)
        State.HitboxSize = Vector3.new(State.HitboxSize.X, v, State.HitboxSize.Z)
        UpdateAndSaveSettings("ReachY", v)
        UpdateHitbox()
    end
})

SizeSection:Slider({
    Title = "–†–∞–∑–º–µ—Ä Z",
    Step = 1,
    Value = {Min = 1, Max = CONFIG.MAX_REACH, Default = SavedSettings.ReachZ or CONFIG.DEFAULT_REACH},
    Callback = function(v)
        State.HitboxSize = Vector3.new(State.HitboxSize.X, State.HitboxSize.Y, v)
        UpdateAndSaveSettings("ReachZ", v)
        UpdateHitbox()
    end
})

-- ============ GK TAB ============
local GkTab = Window:Tab({
    Title = "ü•Ö GK",
    Icon = "rbxassetid://10734950020"
})

local function IsInFansTeam()
    return LocalPlayer.Team and LocalPlayer.Team.Name == "Fans"
end

local function ChangeTeam(teamColor, position)
    if not IsInFansTeam() then
        Notify("–û—à–∏–±–∫–∞", "–¢—ã –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ Fans!", "ban")
        return
    end
    
    pcall(function()
        local args = {teamColor, position}
        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(unpack(args))
        task.wait(0.5)
        Notify("–£—Å–ø–µ—Ö", "–¢—ã —Ç–µ–ø–µ—Ä—å " .. position, "check")
    end)
end

local TeamSection = GkTab:Section({
    Title = "–í—ã–±–æ—Ä –∫–æ–º–∞–Ω–¥—ã"
})

TeamSection:Button({
    Title = "–í—ã–±—Ä–∞—Ç—å Home GK",
    Callback = function()
        ChangeTeam(BrickColor.new(23), "Goalie")
    end
})

TeamSection:Button({
    Title = "–í—ã–±—Ä–∞—Ç—å Away GK",
    Callback = function()
        ChangeTeam(BrickColor.new(141), "Goalie")
    end
})

GkTab:Space()

-- ============ –ü–†–û–î–í–ò–ù–£–¢–ê–Ø –°–ò–°–¢–ï–ú–ê –î–ê–ô–í–û–í (–û–¢–î–ï–õ–¨–ù–ê–Ø) ============

-- –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–π —Å–∏—Å—Ç–µ–º—ã
local AdvancedDiveState = {
    Enabled = false,
    Connection = nil,
    LastDiveTime = 0,
}

local ADVANCED_DIVE_CONFIG = {
    GOAL_DISTANCE_4V4 = 25,
    GOAL_DISTANCE_7V7 = 40,
    BALL_HEADING_THRESHOLD = 0.3,
    MIN_BALL_VELOCITY = 15,
    DIVE_COOLDOWN = 0.5,
}

-- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–∏–Ω–≥–µ
local function GetPlayerPing()
    local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
    return math.floor(ping)
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞: –º—è—á –¥–≤–∏–∂–µ—Ç—Å—è –≤ —Å—Ç–æ—Ä–æ–Ω—É –≤–æ—Ä–æ—Ç?
local function IsBallHeadingToGoal()
    local ball = FindBall()
    if not ball then return false end
    
    local root = GetRoot()
    if not root then return false end
    
    local ballVel = ball.AssemblyLinearVelocity or ball.Velocity or Vector3.zero
    if ballVel.Magnitude < ADVANCED_DIVE_CONFIG.MIN_BALL_VELOCITY then
        return false
    end
    
    -- –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Ç –≤–æ—Ä–æ—Ç –∫ –º—è—á—É
    local directionToGoal = (root.Position - ball.Position).Unit
    local ballDirection = ballVel.Unit
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–≤–∏–∂–µ—Ç—Å—è –ª–∏ –º—è—á –≤ —Å—Ç–æ—Ä–æ–Ω—É –≤–æ—Ä–æ—Ç
    return directionToGoal:Dot(ballDirection) > ADVANCED_DIVE_CONFIG.BALL_HEADING_THRESHOLD
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞: –Ω—É–∂–Ω–æ –ª–∏ –¥–µ–ª–∞—Ç—å –¥–∞–π–≤?
local function ShouldDiveAdvanced()
    if not IsBallHeadingToGoal() then return false end
    
    local ball = FindBall()
    if not ball then return false end
    
    local root = GetRoot()
    if not root then return false end
    
    local ballPos = ball.Position
    local playerPos = root.Position
    local distance = (ballPos - playerPos).Magnitude
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ü–µ–ª–∏
    local gameMode = game.PlaceId -- –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ä–µ–∂–∏–º–∞
    local maxDistance = ADVANCED_DIVE_CONFIG.GOAL_DISTANCE_4V4
    
    return distance <= maxDistance
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞: –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –ª–∏ –≤—ã –±–ª–∏–∑–∫–æ –∫ –≤–æ—Ä–æ—Ç–∞–º?
local function IsPlayerNearGoal()
    local root = GetRoot()
    if not root then return false end
    
    local playerPos = root.Position
    -- –ü—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, –≤–æ—Ä–æ—Ç–∞ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –ø—Ä–∏–º–µ—Ä–Ω–æ –≤ –ø–æ–∑–∏—Ü–∏–∏ X=0
    local distanceToGoal = math.abs(playerPos.X)
    
    return distanceToGoal <= ADVANCED_DIVE_CONFIG.GOAL_DISTANCE_4V4
end

-- –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≤—ã—Å–æ—Ç—É –º—è—á–∞ –∏ –≤—ã–±—Ä–∞—Ç—å –¥–∞–π–≤
local function CalculateDiveDirectionAdvanced()
    local ball = FindBall()
    if not ball then return nil end
    
    local root = GetRoot()
    if not root then return nil end
    
    local ballPos = ball.Position
    local ballVel = ball.AssemblyLinearVelocity or ball.Velocity or Vector3.zero
    local playerPos = root.Position
    
    -- –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –º—è—á–∞ —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ—Ä–µ–π–º–æ–≤
    local predictedPos = ballPos + (ballVel * 0.1)
    local localBallPos = root.CFrame:PointToObjectSpace(predictedPos)
    
    -- –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—ã—Å–æ—Ç—É –º—è—á–∞
    local ballHeight = localBallPos.Y
    local ballXOffset = localBallPos.X
    
    -- –í–´–ë–û–† –¢–ò–ü–ê –î–ê–ô–í–ê
    local diveKeys = {}
    
    if ballHeight > 3 then
        -- –í—ã—Å–æ–∫–∏–π –º—è—á - –¥–æ–±–∞–≤–ª—è–µ–º Space (–≤—ã—Å–æ–∫–∏–π –ø—Ä—ã–∂–æ–∫)
        table.insert(diveKeys, "Space")
    elseif ballHeight < -1 then
        -- –ù–∏–∑–∫–∏–π –º—è—á - –¥–æ–±–∞–≤–ª—è–µ–º X (–Ω–∏–∑–∫–∏–π –ø–æ–¥–∫–∞—Ç)
        table.insert(diveKeys, "X")
    end
    
    -- –ë–æ–∫–æ–≤–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
    if math.abs(ballXOffset) > 2 then
        if ballXOffset < 0 then
            table.insert(diveKeys, "Q") -- –í–ª–µ–≤–æ
        else
            table.insert(diveKeys, "E") -- –í–ø—Ä–∞–≤–æ
        end
    end
    
    -- –ï—Å–ª–∏ –Ω–µ—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –∫–ª–∞–≤–∏—à, –∏—Å–ø–æ–ª—å–∑—É–µ–º Space
    if #diveKeys == 0 then
        table.insert(diveKeys, "Space")
    end
    
    return diveKeys
end

-- –í—ã–ø–æ–ª–Ω–∏—Ç—å –¥–∞–π–≤ —Å –∫–ª–∞–≤–∏—à–∞–º–∏
local function DoDiveAdvanced(diveKeys)
    if not diveKeys or #diveKeys == 0 then return end
    
    local VirtualInputManager = game:GetService("VirtualInputManager")
    
    for _, key in ipairs(diveKeys) do
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode[key], false, game)
        end)
    end
    
    task.wait(0.05)
    
    for _, key in ipairs(diveKeys) do
        pcall(function()
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode[key], false, game)
        end)
    end
end

local AdvancedDiveSection = GkTab:Section({
    Title = "üöÄ –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è —Å–∏—Å—Ç–µ–º–∞ –¥–∞–π–≤–æ–≤"
})

AdvancedDiveSection:Toggle({
    Title = "–í–∫–ª—é—á–∏—Ç—å Advanced Auto Dive",
    Default = false,
    Callback = function(enabled)
        AdvancedDiveState.Enabled = enabled
        
        if not enabled then
            if AdvancedDiveState.Connection then
                AdvancedDiveState.Connection:Disconnect()
                AdvancedDiveState.Connection = nil
            end
            Notify("Advanced Dive", "–í—ã–∫–ª—é—á–µ–Ω ‚úó", "ban")
            return
        end
        
        local ping = GetPlayerPing()
        if ping > 130 then
            Notify("–í–Ω–∏–º–∞–Ω–∏–µ!", "–ü–∏–Ω–≥ " .. ping .. " –º–æ–∂–µ—Ç –≤–ª–∏—è—Ç—å –Ω–∞ –¥–∞–π–≤—ã!", "ban")
        end
        
        AdvancedDiveState.Connection = RunService.Heartbeat:Connect(function()
            if not AdvancedDiveState.Enabled then return end
            
            local currentTime = tick()
            if (currentTime - AdvancedDiveState.LastDiveTime) < ADVANCED_DIVE_CONFIG.DIVE_COOLDOWN then
                return
            end
            
            if ShouldDiveAdvanced() then
                local diveKeys = CalculateDiveDirectionAdvanced()
                if diveKeys then
                    DoDiveAdvanced(diveKeys)
                    AdvancedDiveState.LastDiveTime = currentTime
                    
                    local keyStr = table.concat(diveKeys, " + ")
                    print("üéØ ADVANCED DIVE: " .. keyStr .. " | –ü–∏–Ω–≥: " .. GetPlayerPing())
                end
            end
        end)
        
        Notify("Advanced Dive", "–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω! –ü–∏–Ω–≥: " .. ping .. "ms", "check")
    end
})

AdvancedDiveSection:Button({
    Title = "üìä –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç—É—Å –ø–∏–Ω–≥–∞",
    Callback = function()
        local ping = GetPlayerPing()
        local status = ping <= 130 and "‚úì –û–¢–õ–ò–ß–ù–û" or "‚ö† –í–´–°–û–ö–ò–ô"
        Notify("–ü–∏–Ω–≥", ping .. "ms (" .. status .. ")", ping <= 130 and "check" or "ban")
    end
})

AdvancedDiveSection:Button({
    Title = "üéØ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é —É –≤–æ—Ä–æ—Ç",
    Callback = function()
        local isNear = IsPlayerNearGoal()
        Notify("–ü–æ–∑–∏—Ü–∏—è", isNear and "–í—ã —É –≤–æ—Ä–æ—Ç! ‚úì" or "–í—ã –Ω–µ —É –≤–æ—Ä–æ—Ç ‚úó", isNear and "check" or "ban")
    end
})

AdvancedDiveSection:Button({
    Title = "‚ö° –¢–µ—Å—Ç –¥–∞–π–≤–∞",
    Callback = function()
        local diveKeys = CalculateDiveDirectionAdvanced()
        if diveKeys then
            local keyStr = table.concat(diveKeys, " + ")
            DoDiveAdvanced(diveKeys)
            Notify("–¢–µ—Å—Ç", "–î–∞–π–≤: " .. keyStr, "check")
        else
            Notify("–¢–µ—Å—Ç", "–ù–µ –º–æ–≥—É –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –¥–∞–π–≤", "ban")
        end
    end
})

GkTab:Space()

-- ============ –£–õ–£–ß–®–ï–ù–ù–ê–Ø AUTO DIVE –°–ò–°–¢–ï–ú–ê –° –£–ú–ù–û–ô –õ–û–ì–ò–ö–û–ô ============

local DiveState = {
    Enabled = false,
    Connection = nil,
    LastDiveTime = 0,
    DiveButtons = nil,
    ButtonSearchAttempts = 0,
    BallTrajectory = {},
    LastBallPositions = {},
    DiveHistory = {}, -- –ò—Å—Ç–æ—Ä–∏—è –¥–∞–π–≤–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
}

local DIVE_CONFIG = {
    BASE_DISTANCE = 15,
    MAX_DISTANCE = 25,
    DIVE_COOLDOWN = 0.6,
    REACTION_TIME = 0.1,
    BALL_VELOCITY_THRESHOLD = 8,
    ANTICIPATION = 0.3,
    MAX_SEARCH_ATTEMPTS = 5,
    PREDICTION_FRAMES = 15, -- –ö–∞–¥—Ä—ã –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
    MIN_CONFIDENCE = 0.65, -- –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –≤ –¥–∞–π–≤–µ
    TRAJECTORY_SAMPLES = 5, -- –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–∑—Ü–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
}

-- –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—É—Ç–∏ –ø–æ–∏—Å–∫–∞ –∫–Ω–æ–ø–æ–∫ –¥–∞–π–≤–∞
local DIVE_BUTTON_PATHS = {
    -- –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø—É—Ç—å
    function()
        local playerGui = LocalPlayer:WaitForChild("PlayerGui", 3)
        local mobileCTRL = playerGui:WaitForChild("MobileCTRL", 3)
        local touchControlFrame = mobileCTRL:WaitForChild("TouchControlFrame", 3)
        local jumpButton = touchControlFrame:WaitForChild("JumpButton", 3)
        return {
            left = jumpButton:WaitForChild("LeftDive", 2),
            right = jumpButton:WaitForChild("RightDive", 2)
        }
    end,
    
    -- –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø—É—Ç—å 1
    function()
        local playerGui = LocalPlayer:WaitForChild("PlayerGui", 3)
        local controls = playerGui:FindFirstChild("Controls") or playerGui:FindFirstChild("TouchGui")
        if controls then
            local leftDive = controls:FindFirstChild("LeftDive", true)
            local rightDive = controls:FindFirstChild("RightDive", true)
            if leftDive and rightDive then
                return {left = leftDive, right = rightDive}
            end
        end
        return nil
    end,
    
    -- –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø—É—Ç—å 2 - –ø–æ–∏—Å–∫ –ø–æ –≤—Å–µ–º—É PlayerGui
    function()
        local playerGui = LocalPlayer:WaitForChild("PlayerGui", 3)
        local leftDive = nil
        local rightDive = nil
        
        local function searchRecursive(parent)
            for _, child in pairs(parent:GetChildren()) do
                if child.Name == "LeftDive" and child:IsA("GuiButton") then
                    leftDive = child
                elseif child.Name == "RightDive" and child:IsA("GuiButton") then
                    rightDive = child
                end
                
                if child:IsA("GuiObject") then
                    searchRecursive(child)
                end
            end
        end
        
        searchRecursive(playerGui)
        
        if leftDive and rightDive then
            return {left = leftDive, right = rightDive}
        end
        return nil
    end,
    
    -- –ü–æ–∏—Å–∫ —á–µ—Ä–µ–∑ UserInputService (–∫–ª–∞–≤–∏—à–∏)
    function()
        return {
            left = "Q", -- –û–±—ã—á–Ω–æ –ª–µ–≤—ã–π –¥–∞–π–≤ –Ω–∞ Q
            right = "E" -- –û–±—ã—á–Ω–æ –ø—Ä–∞–≤—ã–π –¥–∞–π–≤ –Ω–∞ E
        }
    end
}

local function FindDiveButtons()
    for i, searchFunc in ipairs(DIVE_BUTTON_PATHS) do
        local success, result = pcall(searchFunc)
        if success and result then
            print("–ù–∞–π–¥–µ–Ω—ã –∫–Ω–æ–ø–∫–∏ –¥–∞–π–≤–∞ –º–µ—Ç–æ–¥–æ–º", i)
            return result, i
        end
    end
    return nil, 0
end

local function FireDiveAction(action, method)
    if method <= 3 then
        -- GUI –∫–Ω–æ–ø–∫–∏
        if action and action.Parent then
            pcall(function()
                local connections = getconnections(action.MouseButton1Click)
                if connections and #connections > 0 then
                    connections[1]:Fire()
                else
                    action.MouseButton1Click:Fire()
                end
            end)
        end
    else
        -- –ö–ª–∞–≤–∏—à–∏
        if typeof(action) == "string" then
            pcall(function()
                local VirtualInputManager = game:GetService("VirtualInputManager")
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode[action], false, game)
                task.wait(0.05)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode[action], false, game)
            end)
        end
    end
end

-- ============ –£–õ–£–ß–®–ï–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê –ü–†–ï–î–°–ö–ê–ó–ê–ù–ò–Ø ============

local function PredictBallTrajectory(ballPos, ballVel, frames)
    local predictions = {}
    local pos = ballPos
    local vel = ballVel
    local gravity = Vector3.new(0, -CONFIG.GRAVITY, 0)
    local dt = 1/60 -- –û–¥–∏–Ω —Ñ—Ä–µ–π–º
    
    for i = 1, frames do
        vel = vel + gravity * dt
        pos = pos + vel * dt
        table.insert(predictions, {pos = pos, vel = vel, frame = i})
    end
    
    return predictions
end

local function AnalyzeBallTrajectory(ballPos, ballVel, playerPos, playerSize)
    local predictions = PredictBallTrajectory(ballPos, ballVel, DIVE_CONFIG.PREDICTION_FRAMES)
    local closestPoint = nil
    local minDistance = math.huge
    local frameOfClose = 0
    
    -- –ù–∞–π—Ç–∏ –±–ª–∏–∂–∞–π—à—É—é —Ç–æ—á–∫—É —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏ –∫ –∏–≥—Ä–æ–∫—É
    for i, pred in ipairs(predictions) do
        local dist = (pred.pos - playerPos).Magnitude
        if dist < minDistance then
            minDistance = dist
            closestPoint = pred
            frameOfClose = i
        end
    end
    
    -- –ê–Ω–∞–ª–∏–∑ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∞—Ç–∞–∫–∏
    local directionToPlayer = (playerPos - ballPos)
    local ballDirection = ballVel
    local approachingDot = directionToPlayer.Unit:Dot(ballDirection.Unit)
    
    -- –í—ã—á–∏—Å–ª—è–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –≤ –ø–æ–ø–∞–¥–∞–Ω–∏–∏
    local confidence = 0
    if closestPoint then
        -- –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –∏ –≤—Ä–µ–º–µ–Ω–∏ –¥–æ –ø–æ–ø–∞–¥–∞–Ω–∏—è
        local distanceFactor = math.max(0, 1 - (minDistance / DIVE_CONFIG.MAX_DISTANCE))
        local timingFactor = 1 - (frameOfClose / DIVE_CONFIG.PREDICTION_FRAMES) -- –†–∞–Ω–Ω–∏–µ –¥–∞–π–≤—ã –ª—É—á—à–µ
        confidence = (distanceFactor * 0.6 + timingFactor * 0.4) * approachingDot
    end
    
    return {
        closestPoint = closestPoint,
        minDistance = minDistance,
        frameOfClose = frameOfClose,
        confidence = confidence,
        isApproaching = approachingDot > 0.2,
    }
end

local function CalculateDiveDirection(ballPos, playerPos, playerRoot, confidence)
    local localBallPos = playerRoot.CFrame:PointToObjectSpace(ballPos)
    local xOffset = localBallPos.X
    
    -- –£–ª—É—á—à–µ–Ω–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å —É—á–µ—Ç–æ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
    local diveLeft = false
    
    if math.abs(xOffset) > 2 then
        -- –Ø—Å–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        diveLeft = xOffset < 0
    else
        -- –ù–µ—è—Å–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º Z –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É
        diveLeft = localBallPos.Z > 0
    end
    
    return diveLeft
end

local DiveSection = GkTab:Section({
    Title = "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π Dive [–£–õ–£–ß–®–ï–ù]"
})

DiveSection:Toggle({
    Title = "–í–∫–ª—é—á–∏—Ç—å Smart Auto Dive",
    Default = SavedSettings.AutoDiveEnabled,
    Callback = function(enabled)
        if not enabled then
            DiveState.Enabled = false
            if DiveState.Connection then
                DiveState.Connection:Disconnect()
                DiveState.Connection = nil
            end
            UpdateAndSaveSettings("AutoDiveEnabled", false)
            Notify("Auto Dive", "–í—ã–∫–ª—é—á–µ–Ω ‚úó", "ban")
            return
        end
        
        DiveState.Enabled = true
        UpdateAndSaveSettings("AutoDiveEnabled", true)
        
        -- –ü–æ–∏—Å–∫ –∫–Ω–æ–ø–æ–∫ –¥–∞–π–≤–∞
        local buttons, method = FindDiveButtons()
        if not buttons then
            Notify("–û—à–∏–±–∫–∞", "–ö–Ω–æ–ø–∫–∏ –¥–∞–π–≤–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã!", "ban")
            DiveState.Enabled = false
            UpdateAndSaveSettings("AutoDiveEnabled", false)
            return
        end
        
        DiveState.DiveButtons = buttons
        DiveState.ButtonMethod = method
        
        local lastBallPos = nil
        local ballVelocity = Vector3.zero
        
        if DiveState.Connection then
            DiveState.Connection:Disconnect()
        end
        
        DiveState.Connection = RunService.Heartbeat:Connect(function()
            if not DiveState.Enabled then return end
            
            local character = LocalPlayer.Character
            local root = GetRoot()
            if not character or not root then return end
            
            local ball = FindBall()
            if not ball then return end
            
            pcall(function()
                local ballPos = ball.Position
                local playerPos = root.Position
                local distance = (ballPos - playerPos).Magnitude
                local currentTime = tick()
                
                -- –†–∞—Å—á–µ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏ –º—è—á–∞
                if lastBallPos then
                    ballVelocity = (ballPos - lastBallPos) * 60
                end
                lastBallPos = ballPos
                
                local ballSpeed = ballVelocity.Magnitude
                
                -- –£–õ–£–ß–®–ï–ù–ù–´–ô –ê–ù–ê–õ–ò–ó –¢–†–ê–ï–ö–¢–û–†–ò–ò
                local trajectoryAnalysis = AnalyzeBallTrajectory(ballPos, ballVelocity, playerPos, State.HitboxSize)
                local confidence = trajectoryAnalysis.confidence
                local isApproaching = trajectoryAnalysis.isApproaching
                local minDistance = trajectoryAnalysis.minDistance
                local frameOfClose = trajectoryAnalysis.frameOfClose
                
                -- –î–ò–ù–ê–ú–ò–ß–ï–°–ö–û–ï –†–ê–°–°–¢–û–Ø–ù–ò–ï –° –£–ß–ï–¢–û–ú –ê–ù–ê–õ–ò–ó–ê
                local dynamicDiveDistance = DIVE_CONFIG.BASE_DISTANCE
                if ballSpeed > DIVE_CONFIG.BALL_VELOCITY_THRESHOLD then
                    dynamicDiveDistance = math.min(
                        DIVE_CONFIG.BASE_DISTANCE + (ballSpeed - DIVE_CONFIG.BALL_VELOCITY_THRESHOLD) * 0.4,
                        DIVE_CONFIG.MAX_DISTANCE
                    )
                end
                
                -- –£–õ–£–ß–®–ï–ù–ù–´–ï –£–°–õ–û–í–ò–Ø –î–õ–Ø DIVE
                local shouldDive = false
                local diveReason = ""
                
                if confidence >= DIVE_CONFIG.MIN_CONFIDENCE and isApproaching then
                    -- –û—Å–Ω–æ–≤–Ω–æ–µ —É—Å–ª–æ–≤–∏–µ: –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –∏ –º—è—á –ø—Ä–∏–±–ª–∏–∂–∞–µ—Ç—Å—è
                    shouldDive = (minDistance <= dynamicDiveDistance) and 
                                (currentTime - DiveState.LastDiveTime) >= DIVE_CONFIG.DIVE_COOLDOWN
                    diveReason = "–¢—Ä–∞–µ–∫—Ç–æ—Ä–∏—è –∞–Ω–∞–ª–∏–∑ (—É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: " .. math.floor(confidence * 100) .. "%)"
                elseif ballSpeed > DIVE_CONFIG.BALL_VELOCITY_THRESHOLD and isApproaching then
                    -- –†–µ–∑–µ—Ä–≤–Ω–æ–µ —É—Å–ª–æ–≤–∏–µ: –≤—ã—Å–æ–∫–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –∏ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ
                    shouldDive = (distance <= dynamicDiveDistance) and 
                                (currentTime - DiveState.LastDiveTime) >= DIVE_CONFIG.DIVE_COOLDOWN
                    diveReason = "–†–µ–∑–µ—Ä–≤–Ω–æ–µ: –±—ã—Å—Ç—Ä—ã–π –º—è—á"
                end
                
                if shouldDive then
                    -- –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–Ω–∞–ª–∏–∑–∞ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
                    local diveLeft = CalculateDiveDirection(
                        trajectoryAnalysis.closestPoint.pos,
                        playerPos,
                        root,
                        confidence
                    )
                    
                    local diveAction = diveLeft and DiveState.DiveButtons.left or DiveState.DiveButtons.right
                    
                    if diveAction then
                        FireDiveAction(diveAction, DiveState.ButtonMethod)
                        DiveState.LastDiveTime = currentTime
                        
                        -- –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
                        local side = diveLeft and "–í–õ–ï–í–û" or "–í–ü–†–ê–í–û"
                        print("üîµ –î–ê–ô–í: " .. side .. " | –ü—Ä–∏—á–∏–Ω–∞: " .. diveReason .. " | –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: " .. math.floor(minDistance) .. "–º | –§—Ä–µ–π–º: " .. frameOfClose)
                    end
                end
            end)
        end)
        
        local methodName = method <= 3 and "GUI –∫–Ω–æ–ø–∫–∏" or "–ö–ª–∞–≤–∏—à–∏"
        Notify("Auto Dive", "–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω (" .. methodName .. ") ‚úì", "check")
    end
})

DiveSection:Slider({
    Title = "–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ª–æ–≤–∫–∏",
    Step = 0.5,
    Value = {Min = 8, Max = 30, Default = SavedSettings.DiveDistance or 15},
    Callback = function(v)
        DIVE_CONFIG.BASE_DISTANCE = v
        UpdateAndSaveSettings("DiveDistance", v)
    end
})

DiveSection:Slider({
    Title = "–°–∫–æ—Ä–æ—Å—Ç—å —Ä–µ–∞–∫—Ü–∏–∏",
    Step = 0.05,
    Value = {Min = 0.2, Max = 1.0, Default = SavedSettings.DiveReactionTime or 0.6},
    Callback = function(v)
        DIVE_CONFIG.DIVE_COOLDOWN = v
        UpdateAndSaveSettings("DiveReactionTime", v)
    end
})

DiveSection:Slider({
    Title = "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å (%)",
    Step = 5,
    Value = {Min = 30, Max = 95, Default = 65},
    Callback = function(v)
        DIVE_CONFIG.MIN_CONFIDENCE = v / 100
        UpdateAndSaveSettings("MinConfidence", v)
    end
})

DiveSection:Slider({
    Title = "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –º—è—á–∞",
    Step = 1,
    Value = {Min = 3, Max = 20, Default = SavedSettings.BallVelocityThreshold or 8},
    Callback = function(v)
        DIVE_CONFIG.BALL_VELOCITY_THRESHOLD = v
        UpdateAndSaveSettings("BallVelocityThreshold", v)
    end
})

-- –ö–Ω–æ–ø–∫–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞–π–≤–∞
DiveSection:Button({
    Title = "–¢–µ—Å—Ç –ª–µ–≤–æ–≥–æ –¥–∞–π–≤–∞",
    Callback = function()
        local buttons, method = FindDiveButtons()
        if buttons then
            FireDiveAction(buttons.left, method)
            Notify("–¢–µ—Å—Ç", "–õ–µ–≤—ã–π –¥–∞–π–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω", "check")
        else
            Notify("–û—à–∏–±–∫–∞", "–ö–Ω–æ–ø–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", "ban")
        end
    end
})

DiveSection:Button({
    Title = "–¢–µ—Å—Ç –ø—Ä–∞–≤–æ–≥–æ –¥–∞–π–≤–∞",
    Callback = function()
        local buttons, method = FindDiveButtons()
        if buttons then
            FireDiveAction(buttons.right, method)
            Notify("–¢–µ—Å—Ç", "–ü—Ä–∞–≤—ã–π –¥–∞–π–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω", "check")
        else
            Notify("–û—à–∏–±–∫–∞", "–ö–Ω–æ–ø–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", "ban")
        end
    end
})
-- ============ STAMINA TAB ============
local StaminaTab = Window:Tab({
    Title = "‚ö° Stamina",
    Icon = "zap",
})

local StaminaSection = StaminaTab:Section({
    Title = "–ë–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è –≤—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å"
})

StaminaSection:Toggle({
    Title = "–í–∫–ª—é—á–∏—Ç—å Infinite Stamina",
    Default = SavedSettings.InfiniteStaminaEnabled,
    Callback = function(v)
        State.InfiniteStaminaEnabled = v
        getgenv().InfiniteStaminaEnabled = v
        UpdateAndSaveSettings("InfiniteStaminaEnabled", v)
        UpdateStamina()
        Notify("Stamina", v and "–í–∫–ª—é—á–µ–Ω–∞ ‚úì" or "–í—ã–∫–ª—é—á–µ–Ω–∞ ‚úó", v and "check" or "ban")
    end
})

-- ============ BALL PREDICTOR ============

local PredictTab = Window:Tab({
    Title = "üé± Ball Predictor",
    Icon = "circle",
})

local PredictionState = {
    Enabled = false,
    Connection = nil,
    CurveFolder = nil,
}

local PREDICT_CONFIG = {
    gravity = 196.2,
    bounceDamping = 0.68,
    groundHeight = 0,
    minBounceVelocity = 8,
    airResistance = 0.99,
    frictionCoefficient = 0.85,
    terminalVelocity = 200,
    segmentCount = 25,
    segmentSize = Vector3.new(0.3, 0.3, 2),
    maxPredictionTime = 10,
    minVelocityThreshold = 3,
    updateRate = 3,
    colorCurve = Color3.fromRGB(0, 255, 0),
    colorLanding = Color3.fromRGB(255, 255, 0),
}

local function CreatePredictorSegments()
    if PredictionState.CurveFolder then
        PredictionState.CurveFolder:Destroy()
    end
    
    PredictionState.CurveFolder = Instance.new("Folder")
    PredictionState.CurveFolder.Name = "BallPredictionCurve"
    PredictionState.CurveFolder.Parent = Workspace
    
    local segments = {}
    for i = 1, PREDICT_CONFIG.segmentCount do
        local segment = Instance.new("Part")
        segment.Name = "Segment_" .. i
        segment.Anchored = true
        segment.CanCollide = false
        segment.CastShadow = false
        segment.Material = Enum.Material.Neon
        segment.Transparency = 0.2
        segment.Size = PREDICT_CONFIG.segmentSize
        segment.Color = PREDICT_CONFIG.colorCurve
        segment.Parent = PredictionState.CurveFolder
        segments[i] = segment
    end
    
    -- –ú–∞—Ä–∫–µ—Ä—ã –ø—Ä–∏–∑–µ–º–ª–µ–Ω–∏—è
    local marker = Instance.new("Part")
    marker.Name = "LandingMarker"
    marker.Anchored = true
    marker.CanCollide = false
    marker.CastShadow = false
    marker.Material = Enum.Material.Neon
    marker.Color = PREDICT_CONFIG.colorLanding
    marker.Transparency = 0.4
    marker.Size = Vector3.new(4, 0.2, 4)
    marker.Shape = Enum.PartType.Cylinder
    marker.Parent = PredictionState.CurveFolder
    
    local ring = Instance.new("Part")
    ring.Name = "LandingRing"
    ring.Anchored = true
    ring.CanCollide = false
    ring.CastShadow = false
    ring.Material = Enum.Material.Neon
    ring.Color = PREDICT_CONFIG.colorLanding
    ring.Transparency = 0.6
    ring.Size = Vector3.new(6, 0.1, 6)
    ring.Shape = Enum.PartType.Cylinder
    ring.Parent = PredictionState.CurveFolder
    
    return segments, marker, ring
end

local function SimulateTrajectory(startPos, startVel)
    local points = {}
    local gravityVector = Vector3.new(0, -PREDICT_CONFIG.gravity, 0)
    
    local pos = startPos
    local vel = startVel
    local time = 0
    local bounceCount = 0
    local pointCount = 0
    
    local dt = 0.033
    local gravityDt = gravityVector * dt
    local airResistance = PREDICT_CONFIG.airResistance ^ dt
    
    while time < PREDICT_CONFIG.maxPredictionTime and bounceCount < 8 and pointCount < 80 do
        time = time + dt
        pointCount = pointCount + 1
        
        vel = (vel + gravityDt) * airResistance
        
        if vel.Y < -PREDICT_CONFIG.terminalVelocity then
            vel = Vector3.new(vel.X, -PREDICT_CONFIG.terminalVelocity, vel.Z)
        end
        
        pos = pos + vel * dt
        points[pointCount] = {pos, vel}
        
        if pos.Y <= PREDICT_CONFIG.groundHeight and vel.Y < 0 then
            pos = Vector3.new(pos.X, PREDICT_CONFIG.groundHeight, pos.Z)
            
            local bounceVelY = -vel.Y * PREDICT_CONFIG.bounceDamping
            vel = Vector3.new(
                vel.X * PREDICT_CONFIG.frictionCoefficient,
                bounceVelY,
                vel.Z * PREDICT_CONFIG.frictionCoefficient
            )
            
            bounceCount = bounceCount + 1
            
            if vel.Magnitude < PREDICT_CONFIG.minBounceVelocity then
                break
            end
        end
        
        if pos.Y < -500 or vel.Magnitude < 0.3 then
            break
        end
    end
    
    return points, pointCount
end

local PredictSection = PredictTab:Section({
    Title = "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–µ–¥–∏–∫—Ç–æ—Ä–∞"
})

PredictSection:Toggle({
    Title = "–í–∫–ª—é—á–∏—Ç—å Ball Predictor",
    Default = SavedSettings.BallPredictorEnabled,
    Callback = function(enabled)
        PredictionState.Enabled = enabled
        UpdateAndSaveSettings("BallPredictorEnabled", enabled)
        
        if not enabled then
            if PredictionState.Connection then
                PredictionState.Connection:Disconnect()
                PredictionState.Connection = nil
            end
            if PredictionState.CurveFolder then
                PredictionState.CurveFolder:Destroy()
                PredictionState.CurveFolder = nil
            end
            Notify("Ball Predictor", "–í—ã–∫–ª—é—á–µ–Ω", "ban")
            return
        end
        
        local segments, marker, ring = CreatePredictorSegments()
        local frameCounter = 0
        
        if PredictionState.Connection then
            PredictionState.Connection:Disconnect()
        end
        
        PredictionState.Connection = RunService.Heartbeat:Connect(function()
            frameCounter = frameCounter + 1
            
            if frameCounter % PREDICT_CONFIG.updateRate ~= 0 then
                return
            end
            
            local ball = FindBall()
            if not ball or not PredictionState.Enabled then
                for i = 1, PREDICT_CONFIG.segmentCount do
                    if segments[i] then segments[i].Transparency = 1 end
                end
                marker.Transparency = 1
                ring.Transparency = 1
                return
            end
            
            local velocity = ball.AssemblyLinearVelocity or ball.Velocity or Vector3.zero
            if velocity.Magnitude < PREDICT_CONFIG.minVelocityThreshold then
                for i = 1, PREDICT_CONFIG.segmentCount do
                    if segments[i] then segments[i].Transparency = 1 end
                end
                marker.Transparency = 1
                ring.Transparency = 1
                return
            end
            
            local points, pointCount = SimulateTrajectory(ball.Position, velocity)
            
            if pointCount > 1 then
                local segmentStep = math.max(1, (pointCount - 1) / (PREDICT_CONFIG.segmentCount - 1))
                
                for i = 1, PREDICT_CONFIG.segmentCount do
                    local pointIndex = math.min(math.floor((i - 1) * segmentStep) + 1, pointCount)
                    local nextIndex = math.min(pointIndex + 1, pointCount)
                    
                    if segments[i] and pointIndex <= pointCount and points[pointIndex] then
                        local currentPos = points[pointIndex][1]
                        local nextPos = points[nextIndex] and points[nextIndex][1] or currentPos
                        local midpoint = (currentPos + nextPos) * 0.5
                        local distance = (nextPos - currentPos).Magnitude
                        
                        if distance > 0.01 then
                            local direction = (nextPos - currentPos) / distance
                            segments[i].Size = Vector3.new(0.3, 0.3, math.max(0.1, distance))
                            segments[i].CFrame = CFrame.lookAt(midpoint, midpoint + direction)
                            segments[i].Transparency = 0.2
                        else
                            segments[i].Position = currentPos
                            segments[i].Transparency = 0.2
                        end
                    end
                end
                
                -- –ù–∞–π—Ç–∏ –ø–µ—Ä–≤–æ–µ –ø—Ä–∏–∑–µ–º–ª–µ–Ω–∏–µ
                for i = 2, pointCount do
                    if points[i] and points[i-1] and 
                       points[i][1].Y <= PREDICT_CONFIG.groundHeight and 
                       points[i-1][1].Y > PREDICT_CONFIG.groundHeight then
                        
                        local landingPos = points[i][1]
                        local markerPos = landingPos + Vector3.new(0, 0.1, 0)
                        marker.CFrame = CFrame.new(markerPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                        marker.Transparency = 0.4
                        
                        local ringPos = landingPos + Vector3.new(0, 0.05, 0)
                        ring.CFrame = CFrame.new(ringPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                        ring.Transparency = 0.6
                        
                        local pulse = math.sin(tick() * 5) * 0.5 + 0.5
                        ring.Size = Vector3.new(6 + pulse, 0.1, 6 + pulse)
                        break
                    end
                end
            end
        end)
        
        Notify("Ball Predictor", "–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω", "check")
    end
})

-- ============ –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ù–ê–°–¢–†–û–ô–ö–ò ============

local SettingsTab = Window:Tab({
    Title = "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏",
    Icon = "settings",
})

local InfoSection = SettingsTab:Section({
    Title = "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–∫—Ä–∏–ø—Ç–µ"
})

InfoSection:Button({
    Title = "üìã –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –ª—É—á—à–µ–≥–æ —Å–µ–π–≤–∞",
    Callback = function()
        Notify("–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏", "‚úì –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å 60-70%\n‚úì –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ 12-18–º\n‚úì –†–µ–∞–∫—Ü–∏—è 0.5-0.7\n‚úì –°–∫–æ—Ä–æ—Å—Ç—å –º—è—á–∞ 7-10", "check")
    end
})

InfoSection:Button({
    Title = "‚ö° –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º",
    Callback = function()
        DIVE_CONFIG.BASE_DISTANCE = 15
        DIVE_CONFIG.DIVE_COOLDOWN = 0.6
        DIVE_CONFIG.BALL_VELOCITY_THRESHOLD = 8
        DIVE_CONFIG.MIN_CONFIDENCE = 0.65
        UpdateAndSaveSettings("DiveDistance", 15)
        UpdateAndSaveSettings("DiveReactionTime", 0.6)
        UpdateAndSaveSettings("BallVelocityThreshold", 8)
        UpdateAndSaveSettings("MinConfidence", 65)
        Notify("–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è", "–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –Ω–∞ –º–∞–∫—Å–∏–º—É–º!", "check")
    end
})

InfoSection:Button({
    Title = "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –º—è—á–∞",
    Callback = function()
        local ball = FindBall()
        if ball then
            local velocity = ball.AssemblyLinearVelocity or ball.Velocity or Vector3.zero
            Notify("–ú—è—á –Ω–∞–π–¥–µ–Ω", "–°–∫–æ—Ä–æ—Å—Ç—å: " .. math.floor(velocity.Magnitude), "check")
        else
            Notify("–ú—è—á –Ω–µ –Ω–∞–π–¥–µ–Ω", "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏–≥—Ä—É", "ban")
        end
    end
})

InfoSection:Button({
    Title = "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–æ–ª—å –∏–≥—Ä–æ–∫–∞",
    Callback = function()
        local isGK = IsGoalkeeper()
        local team = LocalPlayer.Team and LocalPlayer.Team.Name or "–ù–µ—Ç –∫–æ–º–∞–Ω–¥—ã"
        Notify("–†–æ–ª—å", "–ö–æ–º–∞–Ω–¥–∞: " .. team .. " | GK: " .. (isGK and "–î–∞" or "–ù–µ—Ç"), "check")
    end
})

InfoSection:Button({
    Title = "–ù–∞–π—Ç–∏ –∫–Ω–æ–ø–∫–∏ –¥–∞–π–≤–∞",
    Callback = function()
        local buttons, method = FindDiveButtons()
        if buttons then
            local methodNames = {"–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø—É—Ç—å", "–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π 1", "–ü–æ–∏—Å–∫ –ø–æ GUI", "–ö–ª–∞–≤–∏—à–∏"}
            Notify("–ö–Ω–æ–ø–∫–∏ –Ω–∞–π–¥–µ–Ω—ã", methodNames[method] or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –º–µ—Ç–æ–¥", "check")
        else
            Notify("–ö–Ω–æ–ø–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥—É—é –∏–≥—Ä—É", "ban")
        end
    end
})

-- ============ –ó–ê–í–ï–†–®–ï–ù–ò–ï ============

-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
CreateHitbox()
UpdateHitbox()

-- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
task.wait(1)
if SavedSettings.ReachEnabled then
    EnableReach()
    Notify("–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ", "Reach –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤–∫–ª—é—á–µ–Ω", "check")
end

if SavedSettings.InfiniteStaminaEnabled then
    State.InfiniteStaminaEnabled = true
    getgenv().InfiniteStaminaEnabled = true
    UpdateStamina()
    Notify("–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ", "Stamina –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤–∫–ª—é—á–µ–Ω–∞", "check")
end

-- –î–∏–∞–ª–æ–≥ –∑–∞–≥—Ä—É–∑–∫–∏
local Dialog = Window:Dialog({
    Icon = "star",
    Title = "RSS - VETA v3 –£–õ–£–ß–®–ï–ù ‚úì",
    Content = "üéØ –£–ú–ù–´–ô –î–ê–ô–í - –ë–û–õ–¨–®–ï –ù–ï –ü–†–´–ì–ê–ï–®–¨ –ù–ê–£–ì–ê–î!\n\n‚úÖ –ê–Ω–∞–ª–∏–∑ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏ –º—è—á–∞\n‚úÖ –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –Ω–∞ 15 —Ñ—Ä–µ–π–º–æ–≤\n‚úÖ –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –≤ —Ä–µ—à–µ–Ω–∏—è—Ö (60%+)\n‚úÖ –£–º–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è\n‚úÖ –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫\n‚úÖ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è",
    Buttons = {
        {
            Title = "–ù–∞—á–∞—Ç—å!",
            Callback = function()
                Notify("RSS v3", "–£–º–Ω—ã–π –¥–∞–π–≤ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω! –í–∫–ª—é—á–∏ Auto Dive –≤ –º–µ–Ω—é GK", "check")
            end
        }
    }
})

print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
print("‚ïë  RSS - VETA v3 - –£–ú–ù–´–ô –î–ê–ô–í –í–ï–†–°–ò–Ø   ‚ïë")
print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
print("‚úì –°–∏—Å—Ç–µ–º–∞ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏ –∞–∫—Ç–∏–≤–Ω–∞")
print("‚úì –ê–Ω–∞–ª–∏–∑ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏: –í–ö–õ")
print("‚úì –£–º–Ω—ã–π –≤—ã–±–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è: –í–ö–õ")
print("‚úì –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ: –í–ö–õ")
print("")
print("üìã –°–û–í–ï–¢–´:")
print("- –ú–∏–Ω. —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å 60-70% –¥–ª—è –ª—É—á—à–µ–π —Ç–æ—á–Ω–æ—Å—Ç–∏")
print("- –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ª–æ–≤–∫–∏ 12-18–º (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è 15–º)")
print("- –°–∫–æ—Ä–æ—Å—Ç—å —Ä–µ–∞–∫—Ü–∏–∏ 0.5-0.7 —Å–µ–∫")
print("- –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –º—è—á–∞ 7-10 –∫–º/—á")
print("")
print("üéØ –¢–µ–ø–µ—Ä—å –¥–∞–π–≤—ã –£–ú–ù–´–ï - –Ω–µ —Å–ª—É—á–∞–π–Ω—ã–µ!")
