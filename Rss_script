-- ============================================
-- RSS - VETA –£–ª—É—á—à–µ–Ω–Ω—ã–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è —Ñ—É—Ç–±–æ–ª–∞
-- ============================================

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

-- –ö–æ–Ω—Ñ–∏–≥–∏
local CONFIG = {
    DEFAULT_REACH = 10,
    MAX_REACH = 50,
    DIVE_DISTANCE = 10.3,
    DIVE_COOLDOWN = 0.7,
    BALL_NAMES = {"ball", "TPS", "PSoccerBall"},
    GRAVITY = 196.2,
}

-- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
local State = {
    IsReachEnabled = false,
    IsVisualizerEnabled = false,
    HitboxSize = Vector3.new(CONFIG.DEFAULT_REACH, CONFIG.DEFAULT_REACH, CONFIG.DEFAULT_REACH),
    ReachConnection = nil,
    RSSHitbox = nil,
    InfiniteStaminaEnabled = false,
}

getgenv().InfiniteStaminaEnabled = false

-- ============ REACH –°–ò–°–¢–ï–ú–ê ============

local function CreateHitbox()
    if State.RSSHitbox then State.RSSHitbox:Destroy() end

    State.RSSHitbox = Instance.new("BoxHandleAdornment")
    State.RSSHitbox.Name = "RSSHitbox"
    State.RSSHitbox.AlwaysOnTop = false
    State.RSSHitbox.ZIndex = 10
    State.RSSHitbox.Color3 = Color3.fromRGB(0, 255, 0)
    State.RSSHitbox.Transparency = 1
    State.RSSHitbox.Size = State.HitboxSize
    State.RSSHitbox.Adornee = GetRoot()
    State.RSSHitbox.Parent = Workspace.Terrain

    local Glow = Instance.new("BoxHandleAdornment")
    Glow.Name = "Glow"
    Glow.AlwaysOnTop = true
    Glow.ZIndex = 0
    Glow.Color3 = Color3.fromRGB(0, 255, 100)
    Glow.Transparency = 1
    Glow.Size = State.HitboxSize
    Glow.Parent = State.RSSHitbox
end

local function UpdateHitbox()
    if not State.RSSHitbox then CreateHitbox() return end
    
    State.RSSHitbox.Size = State.HitboxSize
    local Glow = State.RSSHitbox:FindFirstChild("Glow")
    if Glow then 
        Glow.Size = State.HitboxSize
        Glow.Transparency = (State.IsReachEnabled and State.IsVisualizerEnabled) and 0.7 or 1
    end
end

local function ReachLoop()
    local root = GetRoot()
    if not root or not State.RSSHitbox then return end

    State.RSSHitbox.Adornee = root
    local Glow = State.RSSHitbox:FindFirstChild("Glow")
    if Glow then Glow.Adornee = root end

    local ball = FindBall()
    if not ball then return end

    local effectiveReach = math.max(State.HitboxSize.X, State.HitboxSize.Y, State.HitboxSize.Z) / 2

    if (ball.Position - root.Position).Magnitude <= effectiveReach then
        for _, part in LocalPlayer.Character:GetChildren() do
            if part:IsA("BasePart") then
                firetouchinterest(part, ball, 0)
                task.wait()
                firetouchinterest(part, ball, 1)
            end
        end
    end
end

local function EnableReach()
    if State.ReachConnection then return end
    State.IsReachEnabled = true
    CreateHitbox()
    UpdateHitbox()
    State.ReachConnection = RunService.Heartbeat:Connect(ReachLoop)
    Notify("Reach", "Reach –≤–∫–ª—é—á–µ–Ω ‚úì", "check")
end

local function DisableReach()
    if State.ReachConnection then 
        State.ReachConnection:Disconnect() 
        State.ReachConnection = nil 
    end
    State.IsReachEnabled = false
    UpdateHitbox()
    Notify("Reach", "Reach –≤—ã–∫–ª—é—á–µ–Ω ‚úó", "ban")
end

-- ============ STAMINA –°–ò–°–¢–ï–ú–ê ============

local speeds = nil
local defaultWalk = 16

local function SetupStamina()
    pcall(function()
        local gui = LocalPlayer:WaitForChild("PlayerGui", 10)
        local stamina = gui:WaitForChild("Stamina", 10)
        local frame = stamina:WaitForChild("Frame", 5)
        speeds = frame:WaitForChild("Speeds", 5)
        defaultWalk = speeds.Walk.Value
    end)
end

local function UpdateStamina()
    if speeds then
        speeds.Walk.Value = State.InfiniteStaminaEnabled and speeds.Run.Value or defaultWalk
    end
end

SetupStamina()
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    SetupStamina()
    UpdateStamina()
    if State.IsReachEnabled then
        CreateHitbox()
    end
end)

local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "RSS - VETA v2",
    Icon = "rbxassetid://106211849494703",
    Author = "–£–ª—É—á—à–µ–Ω–Ω—ã–π —Å–∫—Ä–∏–ø—Ç",
    Folder = "RSSVETA",
})

-- ============ MAIN TAB ============
local MainTab = Window:Tab({
    Title = "üéØ Reach",
    Icon = "target",
})

local ReachSection = MainTab:Section({
    Title = "–û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"
})

ReachSection:Toggle({
    Title = "–í–∫–ª—é—á–∏—Ç—å Reach",
    Default = false,
    Callback = function(v)
        if v then EnableReach() else DisableReach() end
    end
})

ReachSection:Toggle({
    Title = "–ü–æ–∫–∞–∑–∞—Ç—å —Ö–∏—Ç–±–æ–∫—Å",
    Default = false,
    Callback = function(v)
        State.IsVisualizerEnabled = v
        UpdateHitbox()
    end
})

MainTab:Space()

local SizeSection = MainTab:Section({
    Title = "–†–∞–∑–º–µ—Ä—ã —Ö–∏—Ç–±–æ–∫—Å–∞ (X/Y/Z)"
})

local function UpdateSizeUI()
    SizeSection:Slider({
        Title = "–†–∞–∑–º–µ—Ä X: " .. State.HitboxSize.X,
        Step = 1,
        Value = {Min = 1, Max = CONFIG.MAX_REACH, Default = CONFIG.DEFAULT_REACH},
        Callback = function(v)
            State.HitboxSize = Vector3.new(v, State.HitboxSize.Y, State.HitboxSize.Z)
            UpdateHitbox()
        end
    })

    SizeSection:Slider({
        Title = "–†–∞–∑–º–µ—Ä Y: " .. State.HitboxSize.Y,
        Step = 1,
        Value = {Min = 1, Max = CONFIG.MAX_REACH, Default = CONFIG.DEFAULT_REACH},
        Callback = function(v)
            State.HitboxSize = Vector3.new(State.HitboxSize.X, v, State.HitboxSize.Z)
            UpdateHitbox()
        end
    })

    SizeSection:Slider({
        Title = "–†–∞–∑–º–µ—Ä Z: " .. State.HitboxSize.Z,
        Step = 1,
        Value = {Min = 1, Max = CONFIG.MAX_REACH, Default = CONFIG.DEFAULT_REACH},
        Callback = function(v)
            State.HitboxSize = Vector3.new(State.HitboxSize.X, State.HitboxSize.Y, v)
            UpdateHitbox()
        end
    })
end

UpdateSizeUI()

local GkTab = Window:Tab({
    Title = "ü•Ö GK",
    Icon = "rbxassetid://10734950020"
})

local function IsInFansTeam()
    return LocalPlayer.Team and LocalPlayer.Team.Name == "Fans"
end

-- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–º–µ–Ω—ã –∫–æ–º–∞–Ω–¥—ã
local function ChangeTeam(teamColor, position)
    if not IsInFansTeam() then
        Notify("–û—à–∏–±–∫–∞", "–¢—ã –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ Fans!", "ban")
        return
    end
    
    pcall(function()
        local args = {teamColor, position}
        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(unpack(args))
        task.wait(0.5)
        Notify("–£—Å–ø–µ—Ö", "–¢—ã —Ç–µ–ø–µ—Ä—å " .. position, "check")
    end)
end

local TeamSection = GkTab:Section({
    Title = "–í—ã–±–æ—Ä –∫–æ–º–∞–Ω–¥—ã"
})

TeamSection:Button({
    Title = "–í—ã–±—Ä–∞—Ç—å Home GK",
    Callback = function()
        ChangeTeam(BrickColor.new(23), "Goalie")
    end
})

TeamSection:Button({
    Title = "–í—ã–±—Ä–∞—Ç—å Away GK",
    Callback = function()
        ChangeTeam(BrickColor.new(141), "Goalie")
    end
})

GkTab:Space()

-- Auto Dive —Å–∏—Å—Ç–µ–º–∞ (–£–õ–£–ß–®–ï–ù–ù–ê–Ø)
local DiveState = {
    Enabled = false,
    Connection = nil,
    LastDiveTime = 0,
    PredictiveMode = true,
}

-- –ö–æ–Ω—Ñ–∏–≥–∏ –¥–ª—è Auto Dive
local DIVE_CONFIG = {
    BASE_DISTANCE = 12,
    MAX_DISTANCE = 20,
    DIVE_COOLDOWN = 0.5,
    REACTION_TIME = 0.1,
    BALL_VELOCITY_THRESHOLD = 5,
    ANTICIPATION = 0.15, -- –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
}

local DiveSection = GkTab:Section({
    Title = "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π Dive [–£–õ–£–ß–®–ï–ù]"
})

DiveSection:Toggle({
    Title = "–í–∫–ª—é—á–∏—Ç—å Smart Auto Dive",
    Default = false,
    Callback = function(enabled)
        DiveState.Enabled = enabled
        
        if not enabled then
            if DiveState.Connection then
                DiveState.Connection:Disconnect()
                DiveState.Connection = nil
            end
            Notify("Auto Dive", "–í—ã–∫–ª—é—á–µ–Ω ‚úó", "ban")
            return
        end
        
        pcall(function()
            local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
            
            if not IsInFansTeam() then
                Notify("–û—à–∏–±–∫–∞", "–¢—ã –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å Goalie!", "ban")
                DiveState.Enabled = false
                return
            end
            
            -- –ü–æ–∏—Å–∫ –∫–Ω–æ–ø–æ–∫
            local playerGui = LocalPlayer:WaitForChild("PlayerGui")
            local mobileCTRL = playerGui:WaitForChild("MobileCTRL")
            local touchControlFrame = mobileCTRL:WaitForChild("TouchControlFrame")
            local jumpButton = touchControlFrame:WaitForChild("JumpButton")
            local leftDiveButton = jumpButton:WaitForChild("LeftDive")
            local rightDiveButton = jumpButton:WaitForChild("RightDive")
            
            local diveButtonCache = {
                left = leftDiveButton,
                right = rightDiveButton,
            }
            
            local function FireDiveButton(button)
                if not button then return end
                local connections = getconnections(button.MouseButton1Click)
                if connections and #connections > 0 then
                    for _, conn in ipairs(connections) do
                        conn:Fire()
                    end
                else
                    button.MouseButton1Click:Fire()
                end
                task.wait(0.01)
            end
            
            local lastBallPos = nil
            local ballVelocity = Vector3.zero
            
            if DiveState.Connection then
                DiveState.Connection:Disconnect()
            end
            
            DiveState.Connection = RunService.Heartbeat:Connect(function()
                if not DiveState.Enabled or not Character.Parent or not HumanoidRootPart.Parent then 
                    return 
                end
                
                local ball = FindBall()
                if not ball then return end
                
                local ballPos = ball.Position
                local playerPos = HumanoidRootPart.Position
                local distance = (ballPos - playerPos).Magnitude
                local currentTime = tick()
                
                -- –†–∞—Å—á–µ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏ –º—è—á–∞
                if lastBallPos then
                    ballVelocity = (ballPos - lastBallPos) / (1/60)
                end
                lastBallPos = ballPos
                
                local ballSpeed = ballVelocity.Magnitude
                
                -- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ª–æ–≤–∫–∏ (—É—á–∏—Ç—ã–≤–∞–µ—Ç —Å–∫–æ—Ä–æ—Å—Ç—å –º—è—á–∞)
                local dynamicDiveDistance = math.min(
                    DIVE_CONFIG.BASE_DISTANCE + (ballSpeed / 50),
                    DIVE_CONFIG.MAX_DISTANCE
                )
                
                -- –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –º—è—á–∞
                local predictedBallPos = ballPos + (ballVelocity * DIVE_CONFIG.ANTICIPATION)
                local predictedDistance = (predictedBallPos - playerPos).Magnitude
                
                -- –£—Å–ª–æ–≤–∏—è –¥–ª—è dive
                local shouldDive = (distance <= dynamicDiveDistance or predictedDistance <= dynamicDiveDistance) and
                                   ballSpeed >= DIVE_CONFIG.BALL_VELOCITY_THRESHOLD and
                                   (currentTime - DiveState.LastDiveTime) >= DIVE_CONFIG.DIVE_COOLDOWN
                
                if shouldDive then
                    -- –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω—É—é –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –ª—É—á—à–µ–π –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
                    local targetPos = (predictedDistance <= dynamicDiveDistance) and predictedBallPos or ballPos
                    local localBallPos = HumanoidRootPart.CFrame:PointToObjectSpace(targetPos)
                    
                    -- –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ dive
                    if localBallPos.X < -1 then
                        -- –õ–µ–≤—ã–π dive
                        FireDiveButton(diveButtonCache.left)
                    elseif localBallPos.X > 1 then
                        -- –ü—Ä–∞–≤—ã–π dive
                        FireDiveButton(diveButtonCache.right)
                    else
                        -- –í—ã–±–∏—Ä–∞–µ–º —Å—Ç–æ—Ä–æ–Ω—É –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç Z (–≥–ª—É–±–∏–Ω–∞)
                        if localBallPos.Z > 0 then
                            FireDiveButton(diveButtonCache.right)
                        else
                            FireDiveButton(diveButtonCache.left)
                        end
                    end
                    
                    DiveState.LastDiveTime = currentTime
                end
            end)
            
            Notify("Auto Dive", "–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω ‚úì (—É–ª—É—á—à–µ–Ω–Ω—ã–π)", "check")
        end)
    end
})

DiveSection:Slider({
    Title = "–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ª–æ–≤–∫–∏",
    Step = 0.5,
    Value = {Min = 5, Max = 25, Default = 12},
    Callback = function(v)
        DIVE_CONFIG.BASE_DISTANCE = v
    end
})

DiveSection:Slider({
    Title = "–°–∫–æ—Ä–æ—Å—Ç—å —Ä–µ–∞–∫—Ü–∏–∏",
    Step = 0.05,
    Value = {Min = 0.1, Max = 0.5, Default = 0.5},
    Callback = function(v)
        DIVE_CONFIG.DIVE_COOLDOWN = v
    end
})

-- Stamina Tab
local StaminaTab = Window:Tab({
    Title = "‚ö° Stamina",
    Icon = "zap",
})

local StaminaSection = StaminaTab:Section({
    Title = "–ë–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è –≤—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å"
})

StaminaSection:Toggle({
    Title = "–í–∫–ª—é—á–∏—Ç—å Infinite Stamina",
    Default = false,
    Callback = function(v)
        State.InfiniteStaminaEnabled = v
        getgenv().InfiniteStaminaEnabled = v
        UpdateStamina()
        Notify("Stamina", v and "–í–∫–ª—é—á–µ–Ω–∞ ‚úì" or "–í—ã–∫–ª—é—á–µ–Ω–∞ ‚úó", v and "check" or "ban")
    end
})

-- ============ BALL PREDICTOR ============

local PredictTab = Window:Tab({
    Title = "üé± Ball Predictor",
    Icon = "circle",
})

local PredictionState = {
    Enabled = false,
    Connection = nil,
    CurveFolder = nil,
}

local PREDICT_CONFIG = {
    gravity = 196.2,
    bounceDamping = 0.68,
    groundHeight = 0,
    minBounceVelocity = 8,
    airResistance = 0.99,
    frictionCoefficient = 0.85,
    terminalVelocity = 200,
    segmentCount = 25,
    segmentSize = Vector3.new(0.3, 0.3, 2),
    maxPredictionTime = 10,
    minVelocityThreshold = 3,
    updateRate = 3,
    colorCurve = Color3.fromRGB(0, 255, 0),
    colorLanding = Color3.fromRGB(0, 255, 0),
}

local function CreatePredictorSegments()
    if PredictionState.CurveFolder then
        PredictionState.CurveFolder:Destroy()
    end
    
    PredictionState.CurveFolder = Instance.new("Folder")
    PredictionState.CurveFolder.Name = "BallPredictionCurve"
    PredictionState.CurveFolder.Parent = Workspace
    
    local segments = {}
    for i = 1, PREDICT_CONFIG.segmentCount do
        local segment = Instance.new("Part")
        segment.Name = "Segment_" .. i
        segment.Anchored = true
        segment.CanCollide = false
        segment.CastShadow = false
        segment.Material = Enum.Material.Neon
        segment.Transparency = 0.2
        segment.Size = PREDICT_CONFIG.segmentSize
        segment.Color = PREDICT_CONFIG.colorCurve
        segment.Parent = PredictionState.CurveFolder
        segments[i] = segment
    end
    
    -- –ú–∞—Ä–∫–µ—Ä—ã –ø—Ä–∏–∑–µ–º–ª–µ–Ω–∏—è
    local marker = Instance.new("Part")
    marker.Name = "LandingMarker"
    marker.Anchored = true
    marker.CanCollide = false
    marker.CastShadow = false
    marker.Material = Enum.Material.Neon
    marker.Color = PREDICT_CONFIG.colorLanding
    marker.Transparency = 0.4
    marker.Size = Vector3.new(4, 0.2, 4)
    marker.Shape = Enum.PartType.Cylinder
    marker.Parent = PredictionState.CurveFolder
    
    local ring = Instance.new("Part")
    ring.Name = "LandingRing"
    ring.Anchored = true
    ring.CanCollide = false
    ring.CastShadow = false
    ring.Material = Enum.Material.Neon
    ring.Color = PREDICT_CONFIG.colorLanding
    ring.Transparency = 0.6
    ring.Size = Vector3.new(6, 0.1, 6)
    ring.Shape = Enum.PartType.Cylinder
    ring.Parent = PredictionState.CurveFolder
    
    return segments, marker, ring
end

local function SimulateTrajectory(startPos, startVel)
    local points = {}
    local gravityVector = Vector3.new(0, -PREDICT_CONFIG.gravity, 0)
    
    local pos = startPos
    local vel = startVel
    local time = 0
    local bounceCount = 0
    local pointCount = 0
    
    local dt = 0.033
    local gravityDt = gravityVector * dt
    local airResistance = PREDICT_CONFIG.airResistance ^ dt
    
    while time < PREDICT_CONFIG.maxPredictionTime and bounceCount < 8 and pointCount < 80 do
        time = time + dt
        pointCount = pointCount + 1
        
        vel = (vel + gravityDt) * airResistance
        
        if vel.Y < -PREDICT_CONFIG.terminalVelocity then
            vel = Vector3.new(vel.X, -PREDICT_CONFIG.terminalVelocity, vel.Z)
        end
        
        pos = pos + vel * dt
        points[pointCount] = {pos, vel}
        
        if pos.Y <= PREDICT_CONFIG.groundHeight and vel.Y < 0 then
            pos = Vector3.new(pos.X, PREDICT_CONFIG.groundHeight, pos.Z)
            
            local bounceVelY = -vel.Y * PREDICT_CONFIG.bounceDamping
            vel = Vector3.new(
                vel.X * PREDICT_CONFIG.frictionCoefficient,
                bounceVelY,
                vel.Z * PREDICT_CONFIG.frictionCoefficient
            )
            
            bounceCount = bounceCount + 1
            
            if vel.Magnitude < PREDICT_CONFIG.minBounceVelocity then
                break
            end
        end
        
        if pos.Y < -500 or vel.Magnitude < 0.3 then
            break
        end
    end
    
    return points, pointCount
end

local PredictSection = PredictTab:Section({
    Title = "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–µ–¥–∏–∫—Ç–æ—Ä–∞"
})

PredictSection:Toggle({
    Title = "–í–∫–ª—é—á–∏—Ç—å Ball Predictor",
    Default = false,
    Callback = function(enabled)
        PredictionState.Enabled = enabled
        
        if not enabled then
            if PredictionState.Connection then
                PredictionState.Connection:Disconnect()
                PredictionState.Connection = nil
            end
            if PredictionState.CurveFolder then
                PredictionState.CurveFolder:Destroy()
                PredictionState.CurveFolder = nil
            end
            Notify("Ball Predictor", "–í—ã–∫–ª—é—á–µ–Ω", "ban")
            return
        end
        
        local segments, marker, ring = CreatePredictorSegments()
        local frameCounter = 0
        
        if PredictionState.Connection then
            PredictionState.Connection:Disconnect()
        end
        
        PredictionState.Connection = RunService.Heartbeat:Connect(function()
            frameCounter = frameCounter + 1
            
            if frameCounter % PREDICT_CONFIG.updateRate ~= 0 then
                return
            end
            
            local ball = FindBall()
            if not ball or not PredictionState.Enabled then
                for i = 1, PREDICT_CONFIG.segmentCount do
                    if segments[i] then segments[i].Transparency = 1 end
                end
                marker.Transparency = 1
                ring.Transparency = 1
                return
            end
            
            local velocity = ball.AssemblyLinearVelocity
            if velocity.Magnitude < PREDICT_CONFIG.minVelocityThreshold then
                for i = 1, PREDICT_CONFIG.segmentCount do
                    if segments[i] then segments[i].Transparency = 1 end
                end
                marker.Transparency = 1
                ring.Transparency = 1
                return
            end
            
            local points, pointCount = SimulateTrajectory(ball.Position, velocity)
            
            if pointCount > 1 then
                local segmentStep = (pointCount - 1) / (PREDICT_CONFIG.segmentCount - 1)
                
                for i = 1, PREDICT_CONFIG.segmentCount do
                    local pointIndex = math.floor((i - 1) * segmentStep) + 1
                    local nextIndex = math.min(pointIndex + 1, pointCount)
                    
                    if segments[i] and pointIndex <= pointCount then
                        local currentPos = points[pointIndex][1]
                        local nextPos = points[nextIndex][1]
                        local midpoint = (currentPos + nextPos) * 0.5
                        local distance = (nextPos - currentPos).Magnitude
                        
                        if distance > 0.01 then
                            local direction = (nextPos - currentPos) / distance
                            segments[i].Size = Vector3.new(0.3, 0.3, distance)
                            segments[i].CFrame = CFrame.lookAt(midpoint, midpoint + direction)
                            segments[i].Transparency = 0.2
                        else
                            segments[i].Transparency = 1
                        end
                    end
                end
                
                -- –ù–∞–π—Ç–∏ –ø–µ—Ä–≤–æ–µ –ø—Ä–∏–∑–µ–º–ª–µ–Ω–∏–µ
                for i = 2, pointCount do
                    if points[i][1].Y <= PREDICT_CONFIG.groundHeight and 
                       points[i-1][1].Y > PREDICT_CONFIG.groundHeight then
                        
                        local landingPos = points[i][1]
                        local markerPos = landingPos + Vector3.new(0, 0.1, 0)
                        marker.CFrame = CFrame.new(markerPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                        marker.Transparency = 0.4
                        
                        local ringPos = landingPos + Vector3.new(0, 0.05, 0)
                        ring.CFrame = CFrame.new(ringPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                        ring.Transparency = 0.6
                        
                        local pulse = math.sin(tick() * 5) * 0.5 + 0.5
                        ring.Size = Vector3.new(6 + pulse, 0.1, 6 + pulse)
                        break
                    end
                end
            end
        end)
        
        Notify("Ball Predictor", "–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω", "check")
    end
})

-- ============ –ó–ê–í–ï–†–®–ï–ù–ò–ï ============

CreateHitbox()
UpdateHitbox()

local Dialog = Window:Dialog({
    Icon = "star",
    Title = "RSS - VETA v2 ‚úì",
    Content = "–°–∫—Ä–∏–ø—Ç —É–ª—É—á—à–µ–Ω! –ò—â–∏ –±–∞–≥–∏ –≤ Discord",
    Buttons = {
        {
            Title = "Ok",
            Callback = function()
            end
        }
    }
})

Notify("RSS Loaded", "–°–∫—Ä–∏–ø—Ç –≥–æ—Ç–æ–≤! –í–µ—Ä—Å–∏—è 2", "check")
