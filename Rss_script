local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
-- ===== CONFIGURATION =====
local ReachDistance = 1
local IsReachEnabled = false
local IsVisualizerEnabled = false
local HitboxSize = Vector3.new(15, 15, 15)
local ReachConnection = nil
local RSSHitbox = nil

getgenv().InfiniteStaminaEnabled = false
getgenv().StatsLoopRunning = false
-- –°–±—Ä–æ—Å —Å—Ç–∞—Ä—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–µ
if getgenv().AutoDiveConnection then getgenv().AutoDiveConnection:Disconnect() end
if getgenv().GKV2_CONNECTION then getgenv().GKV2_CONNECTION:Disconnect() end
if getgenv().StatsConnection then getgenv().StatsConnection:Disconnect() end

-- –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–π –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–µ
pcall(function()
    if Workspace:FindFirstChild("BallPredictionCurve") then
        Workspace.BallPredictionCurve:Destroy()
    end
end)

-- ===== GLOBAL UTILITY FUNCTIONS =====
local function GetActiveBall()
    local ballNames = {"ball", "TPS", "PSoccerBall"}
    for _, name in ipairs(ballNames) do
        local b = Workspace:FindFirstChild(name)
        if b and b:IsA("BasePart") then return b end
    end
    return nil
end

local function ClickButton(btn)
    if not btn then return false end
    if typeof(getconnections) == "function" and btn.MouseButton1Click then
        local connections = getconnections(btn.MouseButton1Click)
        if connections and #connections > 0 then
            connections[1]:Fire()
            return true
        end
    end
    btn.MouseButton1Click:Fire()
    return true
end

local function TryJump(direction)
    direction = direction or "Center"
    
    -- –ú–æ–±–∞–π–ª: Touch –∫–Ω–æ–ø–∫–∏ —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –æ—à–∏–±–æ–∫
    pcall(function()
        local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
        if not playerGui then return end
        
        -- –ü–æ–ø—ã—Ç–∫–∞ –Ω–∞–π—Ç–∏ MobileCTRL (–æ—Å–Ω–æ–≤–Ω–æ–µ –∏–º—è)
        local mobileCTRL = playerGui:FindFirstChild("MobileCTRL") or playerGui:FindFirstChild("MobileControls")
        if not mobileCTRL then return end
        
        local touchControlFrame = mobileCTRL:FindFirstChild("TouchControlFrame") or mobileCTRL:FindFirstChild("TouchFrame")
        if not touchControlFrame then return end
        
        local jumpButton = touchControlFrame:FindFirstChild("JumpButton") or touchControlFrame:FindFirstChild("JumpBtn")
        if not jumpButton then return end
        
        if direction == "Center" or direction == "Upper" or direction == "Low" then
            ClickButton(jumpButton)
        elseif direction == "Left" or direction == "UpperLeft" then
            local leftDive = jumpButton:FindFirstChild("LeftDive")
            if leftDive then ClickButton(leftDive) end
        elseif direction == "Right" or direction == "UpperRight" then
            local rightDive = jumpButton:FindFirstChild("RightDive")
            if rightDive then ClickButton(rightDive) end
        end
    end)
end

-- ===== HITBOX SYSTEM =====
pcall(function()
    if Workspace.Terrain:FindFirstChild("RSSHitbox") then
        Workspace.Terrain.RSSHitbox:Destroy()
    end
end)

local function CreateHitbox()
    if RSSHitbox then RSSHitbox:Destroy() end

    RSSHitbox = Instance.new("BoxHandleAdornment")
    RSSHitbox.Name = "RSSHitbox"
    RSSHitbox.AlwaysOnTop = true
    RSSHitbox.ZIndex = 10
    RSSHitbox.Color3 = Color3.fromRGB(0, 200, 255)
    RSSHitbox.Transparency = 1
    RSSHitbox.Size = HitboxSize
    RSSHitbox.Adornee = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    RSSHitbox.Parent = Workspace.Terrain

    local InnerGlow = Instance.new("BoxHandleAdornment")
    InnerGlow.Name = "InnerGlow"
    InnerGlow.Parent = RSSHitbox
    InnerGlow.Size = HitboxSize * 0.8
    InnerGlow.Color3 = Color3.fromRGB(100, 255, 200)
    InnerGlow.Transparency = 1
    InnerGlow.AlwaysOnTop = true
    InnerGlow.ZIndex = 5

    local OuterGlow = Instance.new("BoxHandleAdornment")
    OuterGlow.Name = "OuterGlow"
    OuterGlow.Parent = RSSHitbox
    OuterGlow.Size = HitboxSize * 1.3
    OuterGlow.Color3 = Color3.fromRGB(0, 255, 100)
    OuterGlow.Transparency = 1
    OuterGlow.AlwaysOnTop = true
    OuterGlow.ZIndex = 2
end

local function UpdateHitbox()
    if not RSSHitbox then return end
    
    RSSHitbox.Size = HitboxSize
    local InnerGlow = RSSHitbox:FindFirstChild("InnerGlow")
    local OuterGlow = RSSHitbox:FindFirstChild("OuterGlow")
    
    if InnerGlow then InnerGlow.Size = HitboxSize * 0.8 end
    if OuterGlow then OuterGlow.Size = HitboxSize * 1.3 end

    local shouldShow = IsReachEnabled and IsVisualizerEnabled
    
    if shouldShow then
        local pulse = math.sin(tick() * 3) * 0.3 + 0.5
        RSSHitbox.Transparency = 0.3 + (pulse * 0.4)
        if InnerGlow then InnerGlow.Transparency = 0.4 + (pulse * 0.3) end
        if OuterGlow then OuterGlow.Transparency = 0.6 + (pulse * 0.2) end
    else
        RSSHitbox.Transparency = 1
        if InnerGlow then InnerGlow.Transparency = 1 end
        if OuterGlow then OuterGlow.Transparency = 1 end
    end
end

local function GetRoot() 
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end

local function ReachLoop()
    local root = GetRoot()
    if not root or not RSSHitbox then return end

    RSSHitbox.Adornee = root
    local InnerGlow = RSSHitbox:FindFirstChild("InnerGlow")
    local OuterGlow = RSSHitbox:FindFirstChild("OuterGlow")
    if InnerGlow then InnerGlow.Adornee = root end
    if OuterGlow then OuterGlow.Adornee = root end

    local ball = GetActiveBall()
    if not ball then return end

    local touchParts = {
        root,
        LocalPlayer.Character:FindFirstChild("LeftFoot"),
        LocalPlayer.Character:FindFirstChild("RightFoot"),
        LocalPlayer.Character:FindFirstChild("LeftHand"),
        LocalPlayer.Character:FindFirstChild("RightHand"),
    }

    -- Anti-cheat: –º–∞–∫—Å–∏–º—É–º 35 –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –∫–∏–∫–∞
    local maxReach = math.min(35, math.max(HitboxSize.X, HitboxSize.Y, HitboxSize.Z) / 2)
    local effectiveReach = math.max(5, maxReach)

    if (ball.Position - root.Position).Magnitude <= effectiveReach then
        for _, part in ipairs(touchParts) do
            if part and part:IsA("BasePart") then
                firetouchinterest(part, ball, 0)
                firetouchinterest(part, ball, 1)
            end
        end
    end
end

local function EnableReach()
    if ReachConnection then return end
    IsReachEnabled = true
    UpdateHitbox()
    ReachConnection = RunService.Heartbeat:Connect(ReachLoop)
end

local function DisableReach()
    if ReachConnection then 
        ReachConnection:Disconnect() 
        ReachConnection = nil 
    end
    IsReachEnabled = false
    UpdateHitbox()
end

-- ===== STAMINA =====
local speeds = nil
local defaultWalk = 16

local function SetupStamina()
    pcall(function()
        local gui = LocalPlayer:WaitForChild("PlayerGui", 5)
        if not gui then return end
        local stamina = gui:WaitForChild("Stamina", 5)
        if not stamina then return end
        local frame = stamina:WaitForChild("Frame", 5)
        speeds = frame:WaitForChild("Speeds", 5)
        defaultWalk = speeds.Walk.Value

        if InfiniteStaminaEnabled and speeds then
            speeds.Walk.Value = speeds.Run.Value
        end
    end)
end

SetupStamina()
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    SetupStamina()
    CreateHitbox()
end)

-- ===== UI SETUP =====
-- ===== UI SETUP =====
local WindUI = nil
local ok, ui = pcall(function()
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"))()
end)
if ok and ui then
    WindUI = ui
else
    warn("WindUI failed to load, using minimal stub UI - interactive UI may be limited")
    WindUI = {
        CreateWindow = function(opts)
            local Window = {}
            function Window:Tab(t) 
                local Tab = {}
                function Tab:Section(s)
                    local Section = {}
                    function Section:Toggle(tbl) end
                    function Section:Slider(tbl) end
                    function Section:Dropdown(tbl) end
                    function Section:Label(txt) end
                    function Section:Space() end
                    return Section
                end
                return Tab
            end
            return Window
        end,
        Notify = function(...) end
    }
end

local Window = WindUI:CreateWindow({
    Title = "‚öΩ RSS MOBILE GK",
    Icon = "rbxassetid://106211849494703",
    Author = "Optimized for Mobile",
    Folder = "RSSVETA",
})

local MainTab = Window:Tab({ Title = "GK & Player Reach", Icon = "target" })
local MainSection = MainTab:Section({ Title = "Both Reach" })

MainSection:Toggle({
    Title = "Enable Reach",
    Default = false,
    Callback = function(v)
        if v then EnableReach() else DisableReach() end
    end
})

MainSection:Toggle({
    Title = "Show Hitbox",
    Default = false,
    Callback = function(v)
        IsVisualizerEnabled = v
        UpdateHitbox()
    end
})

MainTab:Space()
local SizeSection = MainTab:Section({ Title = "Reach Hitbox Size (X/Y/Z)" })

local function UpdateHitboxSize(axis, value)
    if axis == "X" then HitboxSize = Vector3.new(value, HitboxSize.Y, HitboxSize.Z)
    elseif axis == "Y" then HitboxSize = Vector3.new(HitboxSize.X, value, HitboxSize.Z)
    elseif axis == "Z" then HitboxSize = Vector3.new(HitboxSize.X, HitboxSize.Y, value)
    end
    UpdateHitbox()
end

SizeSection:Slider({ Title = "Size X", Step = 1, Value = {Min = 1, Max = 60, Default = 15}, Callback = function(v) UpdateHitboxSize("X", v) end })
SizeSection:Slider({ Title = "Size Y", Step = 1, Value = {Min = 1, Max = 60, Default = 15}, Callback = function(v) UpdateHitboxSize("Y", v) end })
SizeSection:Slider({ Title = "Size Z", Step = 1, Value = {Min = 1, Max = 60, Default = 15}, Callback = function(v) UpdateHitboxSize("Z", v) end })

-- ===== GK FEATURES =====
local GkTab = Window:Tab({ Title = "GK Features", Icon = "rbxassetid://10734950020" })

local AutoPickSection = GkTab:Section({ Title = "Auto Pick GK" })
AutoPickSection:Dropdown({
    Title = "Choose Team",
    Desc = "Must be in Fans/No Team",
    Values = {"Home GK", "Away GK"},
    AllowNone = true,
    Callback = function(option)
        if not option then return end
        if LocalPlayer.Team and LocalPlayer.Team.Name ~= "Fans" then
            WindUI:Notify({Title = "Error", Icon = "ban", Content = "Must be in Fans/No Team!", Duration = 3})
            return
        end
        
        local teamColor = (option == "Home GK") and BrickColor.new(23) or BrickColor.new(141)
        local success = pcall(function()
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(teamColor, "Goalie")
        end)
        
        if success then
            WindUI:Notify({Title = "‚úÖ Success", Icon = "check", Content = "Changed to " .. option, Duration = 2})
        else
            WindUI:Notify({Title = "‚ùå Error", Icon = "ban", Content = "Failed to change team", Duration = 2})
        end
    end
})

local StatsSection = GkTab:Section({ Title = "GK Stats" })
StatsSection:Label("Stats refresh each second")

local function UpdateStats()
    if not getgenv().StatsLoopRunning then return end
    
    local Character = LocalPlayer.Character
    if not Character then return end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    local ball = GetActiveBall()
    local ballDist = ball and math.floor((HumanoidRootPart.Position - ball.Position).Magnitude) or 0
    local ballSpeed = ball and math.floor(ball.AssemblyLinearVelocity.Magnitude * 10) / 10 or 0
    
    pcall(function()
        StatsSection:Label("Distance to Ball: " .. ballDist .. " studs")
        StatsSection:Label("Ball Speed: " .. ballSpeed .. " m/s")
        StatsSection:Label("Mode: " .. (GKV2_ENABLED and "V2 (Smart)" or (V1_ENABLED and "V1 (Simple)" or "OFF")))
    end)
end

-- –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º—ã–π Stats Loop —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
local function StartStatsLoop()
    if getgenv().StatsConnection then return end
    getgenv().StatsLoopRunning = true
    
    getgenv().StatsConnection = RunService.Heartbeat:Connect(function()
        if not getgenv().StatsLoopRunning then
            getgenv().StatsConnection:Disconnect()
            getgenv().StatsConnection = nil
            return
        end
        UpdateStats()
    end)
end

StartStatsLoop()

-- GK Variables
local GKV2_ENABLED = false
local V1_ENABLED = false
local GKV2_MIN_BALL_SPEED = 4
local GKV2_NEAR_GOAL_DISTANCE_4v4 = 35
local GKV2_NEAR_GOAL_DISTANCE_7v7 = 55
local GKV2_DIVE_COOLDOWN = 0.25
local GKV2_DETECTION_DISTANCE = 55
local GK_GOAL_Z_POSITION = -150

local DIVE_DISTANCE_REGULAR = 35
local DIVE_COOLDOWN_REGULAR = 0.25
local PREDICTION_TIME_REGULAR = 0.25
local MIN_BALL_SPEED_REGULAR = 3

local GKV2LastDive = 0
local V1LastDive = 0

-- GK Logic Functions
local function isBallHeadingToGoal(ball, playerPos)
    if not ball or not playerPos then return false end
    local ballVel = ball.AssemblyLinearVelocity
    local ballSpeed = ballVel.Magnitude
    if ballSpeed < GKV2_MIN_BALL_SPEED then return false end
    
    local ballToGoal = (Vector3.new(playerPos.X, playerPos.Y, GK_GOAL_Z_POSITION) - ball.Position)
    return ballVel:Dot(ballToGoal.Unit) > ballSpeed * 0.15
end

local function isPlayerNearGoal(playerPos)
    local goalPos = Vector3.new(playerPos.X, 5, GK_GOAL_Z_POSITION)
    local distance = (playerPos - goalPos).Magnitude
    local gameMode = math.abs(playerPos.X) < 30 and "4v4" or "7v7"
    return distance <= (gameMode == "7v7" and GKV2_NEAR_GOAL_DISTANCE_7v7 or GKV2_NEAR_GOAL_DISTANCE_4v4)
end

local function calculateDiveDirection(ball, playerCFrame)
    local ballPos = ball.Position
    local ballVel = ball.AssemblyLinearVelocity
    local ballSpeed = ballVel.Magnitude
    
    local predictionTime = math.clamp(0.08 + (ballSpeed / 70), 0.08, 0.4)
    local predictedPos = ballPos + ballVel * predictionTime
    local localBallPos = playerCFrame:PointToObjectSpace(predictedPos)
    
    local dirX = localBallPos.X
    local dirY = localBallPos.Y
    
    -- –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–ª—è –º–æ–±–∏–ª–∞
    local highThreshold = ballSpeed > 20 and 2 or (ballSpeed > 15 and 2.8 or 3.5)
    local sideThreshold = ballSpeed > 20 and 0.8 or (ballSpeed > 15 and 1.2 or 1.8)
    
    if dirY > highThreshold then
        if dirX < -sideThreshold then return "UpperLeft"
        elseif dirX > sideThreshold then return "UpperRight"
        else return "Upper" end
    elseif dirY < 0 then
        return "Low"
    else
        if dirX < -sideThreshold then return "Left"
        elseif dirX > sideThreshold then return "Right"
        else return "Center" end
    end
end

-- GK UI Sections
local DetectionSection = GkTab:Section({ Title = "Settings" })
DetectionSection:Slider({ Title = "Detection Range V1", Step = 1, Value = {Min = 20, Max = 50, Default = 35}, Callback = function(v) DIVE_DISTANCE_REGULAR = v end })
DetectionSection:Slider({ Title = "Detection Range V2", Step = 1, Value = {Min = 25, Max = 60, Default = 55}, Callback = function(v) GKV2_DETECTION_DISTANCE = v end })
DetectionSection:Slider({ Title = "Min Ball Speed V1", Step = 0.5, Value = {Min = 1, Max = 12, Default = 3}, Callback = function(v) MIN_BALL_SPEED_REGULAR = v end })
DetectionSection:Slider({ Title = "Min Ball Speed V2", Step = 0.5, Value = {Min = 1, Max = 12, Default = 4}, Callback = function(v) GKV2_MIN_BALL_SPEED = v end })
DetectionSection:Slider({ Title = "Dive Cooldown", Step = 0.05, Value = {Min = 0.1, Max = 1.0, Default = 0.25}, Callback = function(v) DIVE_COOLDOWN_REGULAR = v; GKV2_DIVE_COOLDOWN = v end })

local TuningSection = GkTab:Section({ Title = "Fine Tuning" })
TuningSection:Slider({ Title = "Prediction Time V1", Step = 0.02, Value = {Min = 0.1, Max = 0.4, Default = 0.25}, Callback = function(v) PREDICTION_TIME_REGULAR = v end })
TuningSection:Slider({ Title = "Goal Distance 4v4", Step = 1, Value = {Min = 15, Max = 40, Default = 35}, Callback = function(v) GKV2_NEAR_GOAL_DISTANCE_4v4 = v end })
TuningSection:Slider({ Title = "Goal Distance 7v7", Step = 1, Value = {Min = 30, Max = 60, Default = 55}, Callback = function(v) GKV2_NEAR_GOAL_DISTANCE_7v7 = v end })
TuningSection:Slider({ Title = "Reaction Speed", Step = 0.02, Value = {Min = 0.1, Max = 0.6, Default = 0.25}, Callback = function(v) DIVE_COOLDOWN_REGULAR = v; GKV2_DIVE_COOLDOWN = v end })

local GKV2Section = GkTab:Section({ Title = "Auto GK V2 (Advanced)" })

local ModeInfo = GKV2Section:Label("Status: Disabled")

-- Toggles with Mutual Exclusion
local V1_Toggle_Func = nil
local V2_Toggle_Func = nil

V2_Toggle_Func = GKV2Section:Toggle({
    Title = "Enable Auto GK V2",
    Desc = "Smart direction prediction",
    Default = false,
    Callback = function(enabled)
        GKV2_ENABLED = enabled
        V1_ENABLED = false
        ModeInfo:Update("Status: " .. (enabled and "üü¢ V2 ACTIVE" or "‚ö´ Disabled"))
        
        if getgenv().GKV2_CONNECTION then getgenv().GKV2_CONNECTION:Disconnect() end
        if getgenv().AutoDiveConnection then getgenv().AutoDiveConnection:Disconnect() end
        
        if enabled then
            WindUI:Notify({Title = "‚úÖ Auto GK V2", Content = "Smart Prediction Enabled", Duration = 2})
        else
            ModeInfo:Update("Status: ‚ö´ Disabled")
            return
        end
        
        getgenv().GKV2_CONNECTION = RunService.Heartbeat:Connect(function()
            if not GKV2_ENABLED then return end
            
            local Character = LocalPlayer.Character
            if not Character then return end
            local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
            local Humanoid = Character:FindFirstChild("Humanoid")
            if not HumanoidRootPart or not Humanoid then return end
            
            local ball = GetActiveBall()
            if not ball then return end
            
            local playerPos = HumanoidRootPart.Position
            local ballVel = ball.AssemblyLinearVelocity
            local ballSpeed = ballVel.Magnitude
            
            if ballSpeed < GKV2_MIN_BALL_SPEED then return end
            if not isBallHeadingToGoal(ball, playerPos) then return end
            if not isPlayerNearGoal(playerPos) then return end
            if (playerPos - ball.Position).Magnitude > GKV2_DETECTION_DISTANCE then return end
            
            local now = tick()
            if now - GKV2LastDive < GKV2_DIVE_COOLDOWN then return end
            
            -- –ü—Ä–æ–≤–µ—Ä–∫–∞: –ø–µ—Ä—Å–æ–Ω–∞–∂ –Ω–∞ –∑–µ–º–ª–µ –∏ –∂–∏–≤–æ–π
            if Humanoid.Health > 0 then
                local humanoidState = Humanoid:GetState()
                if humanoidState ~= Enum.HumanoidStateType.Freefall and humanoidState ~= Enum.HumanoidStateType.Flying then
                    TryJump(calculateDiveDirection(ball, HumanoidRootPart.CFrame))
                    GKV2LastDive = now
                end
            end
        end)
    end
})

local DiveSection = GkTab:Section({ Title = "Auto Dive (V1)" })
V1_Toggle_Func = DiveSection:Toggle({
    Title = "Enable Auto Dive V1",
    Desc = "Simple prediction",
    Default = false,
    Callback = function(enabled)
        V1_ENABLED = enabled
        GKV2_ENABLED = false
        ModeInfo:Update("Status: " .. (enabled and "üîµ V1 ACTIVE" or "‚ö´ Disabled"))
        
        if getgenv().AutoDiveConnection then getgenv().AutoDiveConnection:Disconnect() end
        if getgenv().GKV2_CONNECTION then getgenv().GKV2_CONNECTION:Disconnect() end
        
        if enabled then
            WindUI:Notify({Title = "‚úÖ Auto Dive V1", Content = "Simple Mode Enabled", Duration = 2})
        else
            ModeInfo:Update("Status: ‚ö´ Disabled")
            return
        end

        getgenv().AutoDiveConnection = RunService.Heartbeat:Connect(function()
            if not V1_ENABLED then return end
            
            local Character = LocalPlayer.Character
            if not Character then return end
            local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
            local Humanoid = Character:FindFirstChild("Humanoid")
            if not HumanoidRootPart or not Humanoid then return end
            
            local ball = GetActiveBall()
            if not ball then return end
            
            local ballPos = ball.Position
            local ballVel = ball.AssemblyLinearVelocity
            local ballSpeed = ballVel.Magnitude
            
            if ballSpeed < MIN_BALL_SPEED_REGULAR then return end
            
            local distance = (HumanoidRootPart.Position - ballPos).Magnitude
            if distance <= DIVE_DISTANCE_REGULAR and distance > 0.5 then
                local now = tick()
                if now - V1LastDive >= DIVE_COOLDOWN_REGULAR then
                    -- –ü—Ä–æ–≤–µ—Ä–∫–∞: –ø–µ—Ä—Å–æ–Ω–∞–∂ –Ω–∞ –∑–µ–º–ª–µ –∏ –∂–∏–≤–æ–π
                    if Humanoid.Health > 0 then
                        local humanoidState = Humanoid:GetState()
                        if humanoidState ~= Enum.HumanoidStateType.Freefall and humanoidState ~= Enum.HumanoidStateType.Flying then
                            local predicted = ballPos + ballVel * PREDICTION_TIME_REGULAR
                            local localPos = HumanoidRootPart.CFrame:PointToObjectSpace(predicted)
                            local dirX, dirY = localPos.X, localPos.Y
                            
                            if ballSpeed > 20 then
                                if dirY > 2.5 then
                                    TryJump(dirX < -1.5 and "Left" or (dirX > 1.5 and "Right" or "Upper"))
                                elseif dirY < -0.5 then
                                    TryJump("Center")
                                else
                                    TryJump(dirX < -0.8 and "Left" or (dirX > 0.8 and "Right" or "Center"))
                                end
                            elseif ballSpeed > 12 then
                                if dirY > 3.5 then
                                    TryJump(dirX < -1.8 and "UpperLeft" or (dirX > 1.8 and "UpperRight" or "Upper"))
                                elseif dirY < 0 then
                                    TryJump("Center")
                                else
                                    TryJump(dirX < -1.2 and "Left" or (dirX > 1.2 and "Right" or "Center"))
                                end
                            else
                                if dirY > 4.5 then
                                    TryJump("Upper")
                                else
                                    TryJump(dirX < -1 and "Left" or (dirX > 1 and "Right" or "Center"))
                                end
                            end
                            V1LastDive = now
                        end
                    end
                end
            end
        end)
    end
})

-- ===== STAMINA & PREDICTOR =====
local StaminaTab = Window:Tab({ Title = "Stamina & Extras", Icon = "zap" })
local StaminaSection = StaminaTab:Section({ Title = "Infinite Stamina" })
StaminaSection:Toggle({
    Title = "Enable",
    Default = false,
    Callback = function(v)
        getgenv().InfiniteStaminaEnabled = v
        if speeds then speeds.Walk.Value = v and speeds.Run.Value or defaultWalk end
    end
})

local PredictSection = StaminaTab:Section({ Title = "Ball Predictor" })
local predictionConnection = nil
local curveFolder = nil

PredictSection:Toggle({
    Title = "Enable Predictor",
    Default = false,
    Callback = function(Value)
        if predictionConnection then predictionConnection:Disconnect() predictionConnection = nil end
        if curveFolder then curveFolder:Destroy() curveFolder = nil end
        
        if not Value then return end

        local config = {
            segmentCount = 20,
            colorCurve = Color3.fromRGB(0, 255, 0),
            gravity = Vector3.new(0, -196.2, 0)
        }
        
        curveFolder = Instance.new("Folder", Workspace)
        curveFolder.Name = "BallPredictionCurve"
        
        local segments = {}
        for i=1, config.segmentCount do
            local p = Instance.new("Part", curveFolder)
            p.Anchored, p.CanCollide, p.CastShadow = true, false, false
            p.Material = Enum.Material.Neon
            p.Color = config.colorCurve
            p.Size = Vector3.new(0.3, 0.3, 1)
            segments[i] = p
        end

        predictionConnection = RunService.Heartbeat:Connect(function()
            if not curveFolder or not curveFolder.Parent then
                predictionConnection:Disconnect()
                predictionConnection = nil
                return
            end
            
            local ball = GetActiveBall()
            if not ball then 
                for _, s in ipairs(segments) do s.Transparency = 1 end
                return 
            end
            
            local pos, vel = ball.Position, ball.AssemblyLinearVelocity
            if vel.Magnitude < 2 then 
                 for _, s in ipairs(segments) do s.Transparency = 1 end
                 return 
            end

            local dt = 0.05
            for i=1, config.segmentCount do
                local nextPos = pos + vel * dt + 0.5 * config.gravity * dt * dt
                vel = vel + config.gravity * dt
                
                local seg = segments[i]
                local dist = (nextPos - pos).Magnitude
                seg.Size = Vector3.new(0.3, 0.3, dist)
                seg.CFrame = CFrame.lookAt((pos + nextPos)/2, nextPos)
                seg.Transparency = 0.3
                
                pos = nextPos
                if pos.Y < 0 then break end
            end
        end)
    end
})

CreateHitbox()
UpdateHitbox()

WindUI:Notify({
    Title = "‚öΩ RSS MOBILE",
    Icon = "check",
    Content = "Optimized Mobile Version Loaded!"
})
